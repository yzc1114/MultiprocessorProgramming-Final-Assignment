# 性能评测报告

阐述并发数据结构和多线程测试程序的设计思路，分析系统的正确性和性能，解释所实现的每个方法如何满足可线性化、是否deadlock-free、starvation-free、lock-free或wait-free

## 并发数据结构实现

本程序中一共实现了**十六种不同的**并发数据结构。

其中实现一与实现二，它们存储结构相同，而数据操作方法不同。它们使用了从站点映射到座位的方式，使用位图数组存储。

实现三与实现四也是存储结构相同，它们将每个座位按照一个整数存储，也类似位图，其内部按位存储不同站点是否被占用。其中实现四在退票后将位置较宽的座位缓存在本线程，在接来下的BuyTicket中先从刚刚退票的位置进行搜索，提高座位命中率。

实现五采取了boolean三维数组，与实现一与二的结构类似，但是将每一位的数据扩展为boolean。最终由于速度太慢，不采用该方法。

实现六和七、八采取了类似于实现三和四的思路，但是它们将每个整数存储多个座位的站点信息，如64位整数，若有10个车站，则可以存储7个座位的车站信息。每9位表示一个座位在这10个车站的信息。

实现九实现了一个异步的架构，但是由于不能通过同步的测试，所以不作为最终给出的参考方案之一，仅做学习使用。

实现十在实现三的基础上，使用了大量的后台线程，为每个请求线程一一映射，来维护座位较空闲的区域，提供给BuyTicket方法进行参考。效果一般。

实现十一和十二分别继承了实现三和实现八，在之前实现的基础上，改进了空闲座位搜索方法，将数组为每个线程划分固定的搜索顺序，每个线程在搜索空位时从固定的区域开始搜索，这样提升了数据本地性，能够加快购买速度。

实现十三和十四使用了ThreadLocal的视图方案，但是并不能保证用户买到固定的座位（按照站票理解），这种方法也不作为最终的答案进行参考。

实现十五和十六，使用了jdk内部incubator的向量化指令类，分别在以上两种存储架构中，加速查询功能，进行指令向量化。

### TicketDS内部结构

#### 顶层

在TicketDS内部分别定义多个内部类真正实现业务逻辑。

```java
private TicketingSystem actualImpl;
```

使用actualImpl存储真正调用的类。

```java
public enum ImplType {
    One(ImplOne.class),
    Two(ImplTwo.class),
    Three(ImplThree.class),
    Four(ImplFour.class),
    // Five(ImplFive.class),
    Six(ImplSix.class),
    Seven(ImplSeven.class),
    Eight(ImplEight.class),
    Nine(ImplNine.class),
    Ten(ImplTen.class),
    Eleven(ImplEleven.class),
    Twelve(ImplTwelve.class),
    Thirteen(ImplThirteen.class),
    Fourteen(ImplFourteen.class),
    Fifteen(ImplFifteen.class),
    Sixteen(ImplSixteen.class);
    private final Class<? extends ImplCommon> implClass;

    ImplType(Class<? extends ImplCommon> implClass) {
        this.implClass = implClass;
    }
}
```

使用ImplType枚举类表示分别的7个实现类。初始化时将implClass传入，通过使用java的反射机制，能够动态创建真正的实现类的实例，避免了重复劳动。

```java
private ThreadLocal<HashSet<Long>> soldTickIds;      // 该线程售出的票的id。线程本地变量。
private ThreadLocal<Integer> currTid;                // 当前的tid。线程本地变量。
private AtomicInteger nextTidRegion;						 		 // 下一个tid区域。多线程安全。
private ThreadLocal<Integer> currTidRegion;			 		 // 当前线程的tid区域。
private static final int tidRegionSpan = 10_000_000; // 默认tid区域大小。
```

在顶层处理购票退票的tid生成，以及合法性检测。

为了避免多线程的冲突，这里采取了每个线程存储本地售出的票id的策略。由于购票的线程只可能退掉本线程之前购买的票，所以这里没有必要采取多线程安全的ConcurrentSkipListSet类，使用ThreadLocal将每个线程的售出票id分隔开即可节省大量资源。

在每个线程在购票时会生成的新的票id，为了解决这一步的多线程冲突，我们将每个线程生成tid的范围划出一个区域，这个区域的大小默认为1千万。每个线程在不知道自己的区域起始范围时，使用AtomicInteger类型的nextTidRegion，生成一个新的区域。这时这个线程独占了这片区域，之后的tid生成只需要在这个区域内增加即可。一旦区域内的tid消耗完，重新使用nextTidRegion生成一片新的区域即可。这样避免了每个线程大量地调用AtomicInteger的方法，节省开销。



在实现三个接口的方法时，调用actualImpl对应的方法传递下去。

但在此处进行一些所有内部子类都含有的逻辑，即票的有效无效检测。将购买票的id存入线程安全的跳表集合，当退票的参数id不在已售出的票id内时，判定该票为无效票。

```java
@Override
public Ticket buyTicket(String passenger, int route, int departure, int arrival) {
    Ticket boughtTicket = actualImpl.buyTicket(passenger, route, departure, arrival);
    if (boughtTicket != null) {
        if (this.soldTickIds.get() == null) {
            initThreadLocal();
        }
        soldTickIds.get().add(boughtTicket.tid);
    }
    return boughtTicket;
}

@Override
public int inquiry(int route, int departure, int arrival) {
    return actualImpl.inquiry(route, departure, arrival);
}

@Override
public boolean refundTicket(Ticket ticket) {
    if (soldTickIds.get() == null) {
        initThreadLocal();
    }
    if (!soldTickIds.get().remove(ticket.tid)) {
        // 无效票
        return false;
    }
    return actualImpl.refundTicket(ticket);
}
```

下面介绍内部的十六个实现类。

#### 所有实现方案的顶层类

首先定义了所有实现方案都要继承的顶层类。

这个类内部定义了所有实现都会用到的一些公共内容。

```java
private abstract class ImplCommon implements TicketingSystem {
    public ImplCommon() {
        status = new int[ROUTE_NUM];
        for (int i = 0; i < ROUTE_NUM; i++) {
            status[i] = S_JUST_WROTE;
        }
        statusVH = MethodHandles.arrayElementVarHandle(int[].class);
    }

    protected final VarHandle statusVH;
    protected boolean[][] route2statusForEachThread; // 静态一致性解决方案。

    protected void initStatus() {
        route2statusForEachThread = new boolean[param.ROUTE_NUM][param.THREAD_NUM];
        for (int i = 0; i < route2statusForEachThread.length; i++) {
            route2statusForEachThread[i] = new boolean[param.THREAD_NUM];
        }
    }

    protected void readStatus(int route) {
        for (int i = 0; i < param.THREAD_NUM; i++) {
            statusVH.getAcquire(this.route2statusForEachThread[route - 1], i);
        }
    }

    protected void writeStatus(int route) {
        statusVH.setRelease(this.route2statusForEachThread[route - 1], getMappedThreadID(), false);
    }
  
    // 实现3和4用到的数据结构
    protected class Seat {
        private final int seatIdx;
        private int route;
        private int coach;
        private int seat;
        // ...
    }

    // 实现1和2和5用到的数据结构
    protected class CoachSeatPair {
        int coach;
        int seat;
        int seatIdx;
        // ...
    }
}
```

## 内存可见性，Inquiry静态一致性的解决方案（重点）

在该ImplCommon类中，可以看到定义了一个status二维数组，该数组为route到thread_num的二维boolean映射。

在题目要求中，要求inquiry实现静态一致性，并且要求买票在有票时能够买到票。但是由于java的JMM内存模型会导致很多线程只能看到本地数据副本，当内存里的数据变动时，线程不一定能够知道。

所以我们利用了JMM中定义的happens-before原则解决这个问题。其中有一条为，对volatile的写happens-before于对volatile变量的读。那么当任意一个写入操作结束后，我们将该车次对应的status用volatile的方式写入，随后在inquiry时，读取该volatile变量，只要读到了写入操作结束时写入的值，那么就能保证之前的写入操作对于本次inquiry来说是可见的。无需加任何锁，只需读取一个数据，就能够解决内存可见性，静态一致性的问题。并且这个解决方案对于全部实现方案是通用的。在购票前，读取该status值，也能立即可见其他线程之前的退票操作，能够保证在有余票时必定能买到票。

在实现时，通过使用jdk11提供的VarHandle类，可以对一个数组内部的任意元素使用volatile语义的read和write操作。

但是可以看到我在实现中，并没有使用get/setVolatile方法，而是使用的setRelease和getAcquire方法，这两个方法是比volatile相对弱一点的操作，是成对使用的。它们能够保证getAcquire调用时，如果读取了其他线程的setRelease写入值，能够保证看到在setRelease之前的操作。这是由于setRelease能够保证不会将setRelease前的操作排序到它后面。

而我使用了route到每个thread的映射的二维数组的status，是为了让写入冲突减少。若仅对每个车次设置一个status，则多个线程同时写入一个变量，cpu会设置很多memory barrier，导致严重的延迟。但是我通过将每个线程映射到唯一的写入位置，即可解决该问题。但与此同时的代价就是，读取时需要使用getAcquire语义读取每个位置的变量。不过经过实验验证，即使读取64个值，读取也会是非常快速的。



### 实现一

#### 数据结构

数据结构如下所述：

> 按照车次建立数组，如Route[5]:
> 每个车次下的每个站点建立数组，如station[10]：
> 每个站点包含一个位向量，涵盖所有车厢的所有座位，1表示座位被所占用，如[1, 1, 1, 0, 0, 0, 1]表示有7个座位，其中前三个与最后一个座位已经被占用。

通过以上描述，全部数据使用一个二维数组保存。其中一维下标为车次，二维下标为站点。

车厢概念被消除，仅保留座位概念。通过取模方式计算车厢号码。

``` java
protected final BitSet[][] data;
```

#### Inquery操作实现:

```java
@Override
public int inquiry(int route, int departure, int arrival) {
    // 这一步保证了内存可见性
    readStatus(route);
    if (isParamsInvalid(route, departure, arrival)) {
        return -1;
    }
    BitSet[] station2seats = data[route - 1];
    BitSet seatsMerged = (BitSet) station2seats[departure - 1].clone();
    for (int i = departure - 1; i <= arrival - 1; i++) {
        try {
            seatsMerged.or(station2seats[i]);
            if (seatsMerged.size() != station2seats[i].size()) {
                throw new Exception();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    return SEAT_NUM * COACH_NUM - seatsMerged.cardinality();
}
```

##### 正确性和性能

之后进行参数检查。随后找到对应车次的每个站点的位图数组。每次从内存读取该车次的每个站点的位图，从departure到arrival的每个站点的位向量进行或，获取所有进行或操作后仍为0的位置，`seatsMerged.cardinality()`将会返回位图中设置为1的数量，用每个车次的座位总数减去即得到了空位的数量。

由于使用的是位图，以上操作速度会非常快，实验证明这个实现的inquiry始终是最快的。

##### 满足要求

由于查询只要求静态一致性，使用status检查机制能够实现。没有加任何锁，也没有加任何可能产生无限循环的机制，所以这是wait-free的。wait-free又包含lock-free，所以：

- Wait-free: $\checkmark$
- Lock-free: $\checkmark$

#### BuyTicket操作实现：

```java
@Override
public Ticket buyTicket(String passenger, int route, int departure, int arrival) {
    if (isParamsInvalid(route, departure, arrival)) {
        return null;
    }
    BitSet[] station2seats;
    int seatIdx;
    synchronized (station2seats = data[route - 1]) {
        seatIdx = doBuyTicket(station2seats, departure, arrival);
        // 写入结束后，写入状态，帮助inquiry达成静态一致性。
        writeStatus(route);
    }
    if (seatIdx == -1) {
        return null;
    }
    CoachSeatPair p = new CoachSeatPair(seatIdx);
    return buildTicket(getCurrThreadNextTid(), passenger, route, p.coach, p.seat, departure, arrival);
}
```

##### 正确性和性能

购票前首先也需要检查参数。购票前，我们使用synchronized关键字对对应的车次进行加锁。这里使用的是相对粗粒度的锁，在每个不同的车次上进行操作是可以达到完全平行的，这样能够大幅度提升效率。

再购票后，使用writeStatus写入volatile的状态，帮助前面提到的内存可见性，inquiry静态一致性的达成。

同时由于jdk目前对于synchronized关键字的锁性能优化十分良好，其中对于竞争不激烈到激烈的过程中，它的锁分为：无锁，轻量级锁，偏向锁，重量级锁。jvm内部在竞争激烈时会逐步地升级锁。在竞争不激烈时锁的竞争很少，速度快。

```java
protected int doBuyTicket(BitSet[] station2seats, int departure, int arrival) {
    BitSet seatsMerged = (BitSet) station2seats[departure - 1].clone();
    for (int i = departure - 1; i <= arrival - 1; i++) {
        seatsMerged.or(station2seats[i]);
    }
    int seatIdx = seatsMerged.previousClearBit(SEAT_NUM * COACH_NUM - 1);
    if (seatIdx == -1) {
        // 无票
        return seatIdx;
    }
    for (int i = departure - 1; i <= arrival - 1; i++) {
        station2seats[i].set(seatIdx);
    }
    return seatIdx;
}
```

内部处理使用位图，速度同样是非常快的。

##### 满足要求

使用了synchronized关键字，能够保障多线程对于同一个车次的数据访问是可线性化的。

由于使用synchronized同步块，其中的锁的申请和释放由jvm执行的，某个申请锁的线程最终会获得锁，所以是deadlock-free的，而synchronized同步块不提供线程唤醒的有序性，所以有可能造成某个线程一直在等待调度，无法获取锁，不是starvation-free的。

- Deadlock-free: $\checkmark$

#### RefundTicket操作实现：

```java
@Override
public boolean refundTicket(Ticket ticket) {
    if (isParamsInvalid(ticket.route, ticket.departure, ticket.arrival)) {
        return false;
    }
    BitSet[] station2seats;
    synchronized (station2seats = data[ticket.route - 1]) {
        boolean res = doRefundTicket(station2seats, ticket);
        // 写入结束后，写入状态，帮助inquiry达成静态一致性。
        writeStatus(ticket.route);
        return res;
    }
}
```

##### 正确性和性能

退票前首先也需要检查参数。购票前，我们使用synchronized关键字对对应的车次进行加锁。

性能分析同BuyTicket中一致。

```java
protected boolean doRefundTicket(BitSet[] station2seats, Ticket ticket) {
    // 检查座位所有departure到arrival的站是否全部被占用
    CoachSeatPair p = new CoachSeatPair(ticket.coach, ticket.seat);
    for (int i = ticket.departure - 1; i <= ticket.arrival - 1; i++) {
        if (!station2seats[i].get(p.seatIdx)) {
            return false;
        }
    }
    for (int i = ticket.departure - 1; i <= ticket.arrival - 1; i++) {
        station2seats[i].set(p.seatIdx, false);
    }
    return true;
}
```

具体的doRefundTicket由于使用位图，对于位图的操作速度都是很快的。

##### 满足要求

具体分析与BuyTicket基本一致，能够保证是deadlock-free的。

### 实现二

#### 数据结构

实现二继承了实现一的数据结构，与实现一保持一致。

#### Inquery操作实现：

与[实现一](#实现一)完全一致，不再赘述。

#### BuyTicket操作实现：

```java
@Override
public Ticket buyTicket(String passenger, int route, int departure, int arrival) {
    if (isParamsInvalid(route, departure, arrival)) {
        return null;
    }
    int seatIdx;
    ReentrantLock lock = locks[route - 1];
    try {
        lock.lock();
        BitSet[] station2seats = data[route - 1];
        seatIdx = doBuyTicket(station2seats, departure, arrival);
    } finally {
        writeStatus(route);
        lock.unlock();
    }
    if (seatIdx == -1) {
        return null;
    }
    CoachSeatPair p = new CoachSeatPair(seatIdx);
    return buildTicket(getCurrThreadNextTid(), passenger, route, p.coach, p.seat, departure, arrival);
}
```

##### 正确性和性能

与实现一中的唯一区别即为，将synchronized关键字替换为了ReentrantLock进行加锁的操作。

性能相比synchronized可能较差。但内部由于使用位图操作，同时由于车次能够造成分流，速度仍会较快。

##### 满足要求

使用了ReentrantLock进行加锁，能够保障多线程对于同一个车次的数据访问是可线性化的。

该函数是阻塞的。使用了try-finally结构进行上锁-释放锁，ReentrantLock保证了某个申请锁的线程最终会获得锁，所以是deadlock-free的，而ReentrantLock并不提供等待线程的唤醒有序性，所以有可能造成某个线程一直在等待调度，无法获取锁，不是starvation-free的。

- Deadlock-free: $\checkmark$

#### RefundTicket操作实现：

```java
@Override
public boolean refundTicket(Ticket ticket) {
    if (isParamsInvalid(ticket.route, ticket.departure, ticket.arrival)) {
        return false;
    }
    BitSet[] station2seats = data[ticket.route - 1];
    ReentrantLock lock = locks[ticket.route - 1];
    try {
        lock.lock();
        return doRefundTicket(station2seats, ticket);
    } finally {
        writeStatus(ticket.route);
        lock.unlock();
    }
}
```

##### 正确性和性能

与上面BuyTicket中的分析基本一致。

##### 满足要求

与上面BuyTicket中的分析基本一致。能够保障deadlock-free的实现。

Deadlock-free: $\checkmark$

### 实现三

#### 数据结构

> 数据结构：只建立一个超长数组。数组长度为 ROUTE_NUM * COACH_NUM * SEAT_NUM
> 将全部车次，全部车厢，全部座位放置到一个长数组中，避免嵌套数组的多次访存开销。
> 每个元素为int，该数字的每个比特表示在某个车站是否有人已经占座。

数据使用两种数组存储，分别是站点数较少时的intArray。

使用VarHandle提供的变量访问类，用来针对数组内的每个元素进行不同类型的访存操作。

其中包括Plain，Opaque，Acquire，Release以及Volatile五类访问变量的类型。

使用VarHandle支持的CompareAndSet原语，可以对数组内的任意元素进行CAS修改，避免加锁。

#### 位图mask加速（重要）

在本实现中，由于一个座位按位存储其每个座位的信息，如果要检查该座位从某个站点到某个站点的占用信息，可以采用mask模板的方式进行加速。

举例：

当一个座位信息为：`0b0001110000`，最右侧有4个0，随后是3个1。这个就表示该座位的从5车站到7车站已经被人占用了。那么此时如果要判断该座位从车站1到车站6是否有座位，最简单的想法即为，分别检查对应位数上是否有1，只要有一个1，那么就没有余票。但是如果使用循环的方式检查会非常慢。我们采取了一个mask策略。从车站1到车站6的mask为`0b0000111111`，这个mask与前面的座位信息直接相与，得到`0b0000110000`，这个数大于0，就代表这个座位从车站1到车站6没有余票。如果要检查从车站1到车站2，它的mask为`0b0000000011`，与前面的座位信息相与会得到0，这时就可以判定该座位是可以买的。

那么每个车站到另外车站的全部mask都可以通过提前生成的方式，避免重复的位运算，可以极大地提升检察座位是否有空的效率。

```java
protected void initMasks() {
    int maxStation = 32;
    stationMasks = new int[maxStation];
    for (int i = 0; i < maxStation; i++) {
        stationMasks[i] = 1 << i;
    }
    dep2arrOnesMasks = new int[maxStation][];
    dep2arrZerosMasks = new int[maxStation][];
    for (int i = 0; i < dep2arrOnesMasks.length; i++) {
        dep2arrOnesMasks[i] = new int[maxStation];
        dep2arrZerosMasks[i] = new int[maxStation];
    }
    // 生成每个车站到另外车站的mask。
    for (int i = 0; i < maxStation; i++) {
        for (int j = i + 1; j < maxStation; j++) {
            int l = j - i;
            int ones = ((~0) >>> (maxStation - l - 1));
            ones <<= i;
            dep2arrOnesMasks[i][j] = ones;
            dep2arrZerosMasks[i][j] = ~ones;
        }
    }
}
```



#### Inquery操作实现:

```java
@Override
public int inquiry(int route, int departure, int arrival) {
    if (isParamsInvalid(route, departure, arrival)) {
        return -1;
    }
    // 保证内存可见性
    readStatus(route);
    int res = 0;
    for (int i = (route - 1) * COACH_NUM * SEAT_NUM; i < route * COACH_NUM * SEAT_NUM; i++) {
        // 保证可见性后使用plain的方式读取即可
        if (checkSeatInfo(readSeatInfoPlain(i), departure, arrival, false)) {
            // 当前座位idx为i，如果检查从departure 到 arrival之间的位数都为false，即可证明该座位的该区间没有被占用，可以增加余票数量。
            res++;
        }
    }
    return res;
}
```

##### 正确性和性能

首先进行参数检查。随后通过遍历整个车次对应的数组范围，检查每个座位信息，查看其是否满足从departure到arrival的位数都为false，如果都为false即可证明该座位在该区间内是可以乘坐的，即可将余票增加1。

由于没有进行加锁等操作，性能还算可以，但由于需要遍历每个座位的信息，循环次数较大，相对于实现1和2比较耗时。

##### 满足要求

查询只要求静态一致性，由于在读取数据前，使用了readStatus读取了volatile变量，刷新了cache。所以可以保证查询操作在没有其他buy和refund操作的情况下，能够查询到内存中的精确数据。所以能够保证静态一致性的实现。

该方法是非阻塞的。由于没有加互斥锁，并且也没有执行CAS操作等可能产生无限循环的操作，所以调用该方法的所有线程最终都会返回，是wait-free的，而wait-free包含了lock-free的定义，所以：

- Lock-free: $\checkmark$
- Wait-free: $\checkmark$

#### BuyTicket操作实现：

```java
@Override
public Ticket buyTicket(String passenger, int route, int departure, int arrival) {
    readStatus(route);
    if (isParamsInvalid(route, departure, arrival)) {
        return null;
    }
    int left = (route - 1) * COACH_NUM * SEAT_NUM;
    int right = route * COACH_NUM * SEAT_NUM - 1;
    ThreadLocalRandom random = ThreadLocalRandom.current();
    int startIdx = random.nextInt(left, right + 1);
    int currIdx = startIdx;
    boolean buyResult = false;
    while (currIdx >= left) {
        buyResult = setOccupiedInverted(route, currIdx, departure, arrival, true, true);
        if (buyResult) {
            break;
        }
        currIdx--;
    }
    if (!buyResult) {
        currIdx = startIdx + 1;
        while (currIdx <= right) {
            buyResult = setOccupiedInverted(route, currIdx, departure, arrival, true, true);
            if (buyResult) {
                break;
            }
            currIdx++;
        }
    }
    if (!buyResult) {
        // 无余票
        return null;
    }
    Seat s = new Seat(currIdx);
    return buildTicket(getCurrThreadNextTid(), passenger, route, s.getCoach(), s.getSeat(), departure, arrival);
}
```

##### 正确性和性能

首先使用readStatus保障内存可见性。

然后进行参数检查。随后在整条车次对应的数组范围内，生成一个随机起始搜索点，该随机数生成使用了ThreadLocalRandom类，能够提升生成随机数的性能。

从该随机起始搜索点先向左侧搜索，每遇到一个新的点位，便尝试调用setOccupiedInverted进行购买。若向左侧一直没有搜索到可以购买的座位，即再从一开始生成的位置向右侧开始搜索。

搜索结束后若仍没有成功购买，则认为无余票。

在尝试购买时使用了setOccupiedInverted函数，如下所示：

```java
protected boolean setOccupiedInverted(int route, int seatIdx, int departure, int arrival, boolean occupied, boolean tryWithLoop) {
    int expectedSeatInfo, newSeatInfo;
    for (; ; ) {
        expectedSeatInfo = readSeatInfoPlain(seatIdx);
        if (!checkSeatInfo(expectedSeatInfo, departure, arrival, !occupied)) {
            // 从departure到arrival站区间内，有与occupied相反的位数，即
            // 若occupied为true，即我们想将departure到arrival的站点全部设置为true，首先需要确保这些站点当前为false。
            // 若有invert，则认为当前座位已被占，无法购买。
            return false;
        }
        newSeatInfo = expectedSeatInfo;
        if (occupied) {
            newSeatInfo |= dep2arrOnesMasks[departure - 1][arrival - 1];
        } else {
            newSeatInfo &= dep2arrZerosMasks[departure - 1][arrival - 1];
        }
        boolean fail = !vh.compareAndSet(intArray, seatIdx, expectedSeatInfo, newSeatInfo);
        if (!fail) {
            writeStatus(route);
            return true;
        }
        if (!tryWithLoop) {
            return false;
        }
    }
}
```

该函数的含义是：将某个座位对应的站点信息，从departure到arrival的站点进行翻转。举例说明：

该座位的站点信息为整数i，该整数i的前10位表示在该站点是否被占用，如：[0,0,0,0,1,1,1,0,0,0]表示该座位从第四站到第六站被占用了。

这里使用了位图mask进行修改，速度很快。

那么此时想要购买该座位的第一到第二站，则需要调用该函数将该数字的前两位进行翻转。该翻转过程使用VarHandle提供的CompareAndSet原语。当修改前的读取的内容与写入时的数据不一致时，将不会进行修改。这样可以保证多线程的安全性。

使用该方法的查找座位的速度比较慢，需要多次搜索。而CompareAndSet使用了原子原语保证正确性，没有加锁，性能较好。

在CAS成功后，调用writeStatus，帮助实现内存可见性。

##### 满足要求

通过使用CAS操作进行数据写入，使得多个线程若同时进入循环内部，调用该段代码，只有一个能够调用成功，其余线程即会重新循环进入下一次调用，保证了该操作的可线性化性。

CAS操作避免了加锁，是非阻塞的。并且当多个线程并发执行CAS操作时，根据其原语的执行特性，能够保证至少其中有一个能够最终返回，所以是lock-free的。而在有很多新的线程持续进入CAS操作环境中时，有可能造成某个线程持续地CAS原语执行失败，而造成其一直处于循环当中。CAS本身不能提供它脱离这种长期循环的机制，所以它并不是wait-free的。

- Lock-free: $\checkmark$

#### RefundTicket操作实现：

```java
@Override
public boolean refundTicket(Ticket ticket) {
    if (isParamsInvalid(ticket.route, ticket.departure, ticket.arrival)) {
        return false;
    }
    Seat s = new Seat(ticket.route, ticket.coach, ticket.seat);
    return setOccupiedInverted(ticket.route, s.getSeatIdx(), ticket.departure, ticket.arrival, false, true);
}
```

不需要进行随机搜索，直接调用setOccupiedInverted进行退票即可。

##### 正确性和性能

与BuyTicket中实现相比，避免了随机搜索查找的开销，其余一致，不再赘述。

##### 满足要求

与BuyTicket中实现一致，不再赘述。

Lock-free: $\checkmark$

### 实现四

实现四实现思路与实现三类似，但是在如何寻找空闲座位的策略上进行了修改。

实现三中，仅仅采取了随机的策略。本实现中，认为本线程刚刚退票的那些座位有更大的概率有空闲位置，所以从他们之间首先开始寻找空位。

```java
ThreadLocal<Map<Integer, List<Integer>>> justRefundSeatIdxes;

public ImplFour() {
    super();
    justRefundSeatIdxes = new ThreadLocal<>();
}
```

使用ThreadLocal的变量，存储那些刚刚退票的座位。

#### BuyTicket实现

```java
@Override
public Ticket buyTicket(String passenger, int route, int departure, int arrival) {
    if (isParamsInvalid(route, departure, arrival)) {
        return null;
    }
    readStatus(route);
    boolean buyResult = false;
    int currIdx = -1;

    Map<Integer, List<Integer>> mapSeatIdxes = justRefundSeatIdxes.get();
    List<Integer> seatIdxes = mapSeatIdxes == null ? null : mapSeatIdxes.get(route);
    while (seatIdxes != null && seatIdxes.size() > 0) {
        currIdx = seatIdxes.remove(seatIdxes.size() - 1);
        buyResult = setOccupiedInverted(route, currIdx, departure, arrival, true, true);
        if (buyResult) {
            break;
        }
    }
    // ...省略
}
```

只给出了与实现三不同的部分。首先从这些刚刚退票的位置开始寻找，认为这些座位有空位的概率更高。

##### 正确性和性能

与实现三相比，从刚退票的位置开始找，它的购票可能稍微快一点。

##### 满足要求

与实现三一致。

- Lock-free: $\checkmark$

#### RefundTicket实现

```java
@Override
public boolean refundTicket(Ticket ticket) {
    if (isParamsInvalid(ticket.route, ticket.departure, ticket.arrival)) {
        return false;
    }
    Seat s = new Seat(ticket.route, ticket.coach, ticket.seat);
    boolean suc = setOccupiedInverted(ticket.route, s.getSeatIdx(), ticket.departure, ticket.arrival, false, true);
    if (suc) {
        if (justRefundSeatIdxes.get() == null) {
            justRefundSeatIdxes.set(new HashMap<>());
            for (int i = 0; i < ROUTE_NUM; i++) {
                justRefundSeatIdxes.get().put(i + 1, new ArrayList<>(COACH_NUM * SEAT_NUM));
            }
        }
        if (ticket.arrival - ticket.departure >= 5)
            justRefundSeatIdxes.get().get(s.route).add(s.seatIdx);
    }
    return suc;
}
```

##### 正确性和性能

在退票成功后，将退掉的票存入到ThreadLocal的变量中。

与实现三相比，增大的开销就是存储这部分数据的开销。

##### 满足要求

与实现三一致。

Lock-free: $\checkmark$

### 实现五

#### 数据结构

> 使用boolean[][][]数组代替BitSet的方案。这种方案能够在座位粒度上进行同步。
> 是ImplOne数据结构的变种。但是由于使用boolean数组，导致不能利用位图的快速合并功能，其查询的复杂度大大提升。效率比较一般。

使用三维数组代替了BitSet。

在实现1和2中，必须在车次级别进行加锁。但是在本实现中，可以针对每个座位的粒度进行CAS加锁。

```java
protected final boolean[][][] data;

protected final AtomicBoolean[][] seatFlags;

public ImplFive() {
    super();
    data = new boolean[ROUTE_NUM][STATION_NUM][COACH_NUM * SEAT_NUM];
    seatFlags = new AtomicBoolean[ROUTE_NUM][COACH_NUM * SEAT_NUM];
    for (AtomicBoolean[] seatFlag : seatFlags) {
        for (int i = 0; i < seatFlag.length; i++) {
            seatFlag[i] = new AtomicBoolean(false);
        }
    }
}
```

#### Inquiry实现

```java
private boolean[] inquiryMergedSeats(int route, int departure, int arrival) {
    boolean[][] station2seats = data[route - 1];
    boolean[] seatsMerged = new boolean[COACH_NUM * SEAT_NUM];
    for (int i = departure - 1; i <= arrival - 1; i++) {
        boolean[] seats = station2seats[i];
        for (int j = 0; j < seats.length; j++) {
            seatsMerged[j] = seatsMerged[j] || seats[j];
        }
    }
    return seatsMerged;
}
```

##### 正确性与性能

与实现一和二的类似，将每个位置的信息进行与。但是这里并不能利用位图的数据压缩特性，在实验中发现它的性能非常差。

##### 满足要求

没有无限循环，没有加锁。是wait-free的。

- Lock-free: $\checkmark$
- Wait-free: $\checkmark$

#### BuyTicket实现

```java
@Override
public Ticket buyTicket(String passenger, int route, int departure, int arrival) {
    ThreadLocalRandom random = ThreadLocalRandom.current();
    readStatus(route);
    try {
        boolean[][] station2seats = data[route - 1];
        while (true) {
            boolean[] seatsMerged = inquiryMergedSeats(route, departure, arrival);
            boolean haveFoundAnEmpty = false;
            int start = random.nextInt(COACH_NUM * SEAT_NUM);
            int count = 0;
            findNextEmpty:
            for (int seatIdx = start; count < COACH_NUM * SEAT_NUM; seatIdx = (seatIdx + 1) % (SEAT_NUM * COACH_NUM)) {
                count++;
                if (seatsMerged[seatIdx]) {
                    continue;
                }
                // find a empty seat
                haveFoundAnEmpty = true;
                while(true) {
                    if (!seatFlags[route - 1][seatIdx].compareAndSet(false, true)) {
                        Thread.sleep(0, random.nextInt(10));
                    } else {
                        // do check again
                        for (int currStation = departure - 1; currStation <= arrival - 1; currStation++) {
                            if (station2seats[currStation][seatIdx]) {
                                seatFlags[route - 1][seatIdx].setOpaque(false);
                                continue findNextEmpty;
                            }
                        }
                        for (int currStation = departure - 1; currStation <= arrival - 1; currStation++) {
                            station2seats[currStation][seatIdx] = true;
                        }
                        seatFlags[route - 1][seatIdx].setOpaque(false);
                        CoachSeatPair p = new CoachSeatPair(seatIdx);
                        return buildTicket(getCurrThreadNextTid(), passenger, route, p.coach, p.seat, departure, arrival);
                    }
                }
            }
            if (!haveFoundAnEmpty) {
                return null;
            }
        }
    } catch (Exception e) {
        System.out.println(e.getMessage());
        System.exit(-1);
        return null;
    } finally {
        writeStatus(route);
    }
}
```

##### 正确性与性能

首先readStatus保证内存可见性。

在一个无限循环中，调用inquiryMergedSeats，获得从departure到arrival的合并后的座位信息。从中开始随机的寻找，直到找到一个空的位置，使用CAS写入flag，写入成功后，将再一次检查这个座位是否为空的。这里的double check如果不做有可能造成这个座位在取到锁后，这个座位已经被别人占用的情况。

如果double check发现该座位被占，则将重新循环，寻找下一个空位。如果没有被占，则使用VarHandle提供的setOpaque方法，将占用信息直接写入内存。

没有加锁，仅使用CAS在每个座位的粒度上进行同步，相比实现一和二有巨大的优势。

##### 满足要求

使用CAS写入flag的方式进行同步，在内部有多个无限循环。由于CAS操作可能导致某个线程一直竞争失败，并且没有加锁，所以它是lock-free的。

- Lock-free: $\checkmark$

#### RefundTicket实现

```java
@Override
public boolean refundTicket(Ticket ticket) {
    boolean[][] station2seats = data[ticket.route - 1];
    // 检查座位所有departure到arrival的站是否全部被占用
    CoachSeatPair p = new CoachSeatPair(ticket.coach, ticket.seat);
    for (int i = ticket.departure - 1; i <= ticket.arrival - 1; i++) {
        if (!station2seats[i][p.seatIdx]) {
            return false;
        }
    }
    ThreadLocalRandom random = ThreadLocalRandom.current();
    while (!seatFlags[ticket.route - 1][p.seatIdx].compareAndSet(false, true)) {
        try {
            Thread.sleep(0, random.nextInt(5));
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
    for (int i = ticket.departure - 1; i <= ticket.arrival - 1; i++) {
        station2seats[i][p.seatIdx] = false;
    }
    seatFlags[ticket.route - 1][p.seatIdx].setOpaque(false);
    writeStatus(ticket.route);
    return true;
}
```

##### 正确性与性能

相对比较简单，同样使用CAS写入flag的方式进行同步，没有加锁。性能比实现1和2要好得多。

##### 满足要求

与buyTicket一致。

- Lock-free: $\checkmark$

### 实现六

#### 数据结构

> 数据结构：针对每个车次建立数组，与实现三类似，但是在这里每个数字存储多个座位信息。
> 每个元素为long，假设有10个车站，则第1到第10个比特表示第一个座位的信息，第11到第20个比特表示第二个座位的信息。将数据进一步进行压缩。

#### 位图mask加速（重要）

与实现三和四使用的mask加速类似，这里也采取了mask加速，但是使用mask数量更多，因为这里每个元素要存储多个座位的信息，那么一个元素针对其内部的多个座位就要多存储多个mask。

```java
protected void initMasks() {
    dep2arr2posMasks = new long[STATION_NUM][STATION_NUM][seatsPerLong];
    for (int i = 0; i < dep2arr2posMasks.length; i++) {
        dep2arr2posMasks[i] = new long[STATION_NUM][seatsPerLong];
        for (int j = i + 1; j < dep2arr2posMasks[i].length; j++) {
            dep2arr2posMasks[i][j] = new long[seatsPerLong];
        }
    }
    for (int i = 0; i < STATION_NUM; i++) {
        for (int j = i + 1; j < STATION_NUM; j++) {
            for (int k = 0; k < seatsPerLong; k++) {
                if (k == 0) {
                    int l = j - i;
                    int ones = 0;
                    for (int m = 0; m < STATION_NUM; m++) {
                        ones |= 1 << m;
                    }
                    int onesMask = (ones >> (STATION_NUM - l) - 1) << i;
                    dep2arr2posMasks[i][j][0] = onesMask;
                } else {
                    dep2arr2posMasks[i][j][k] = dep2arr2posMasks[i][j][k - 1] << STATION_NUM;
                }
            }
        }
    }
}
```

#### Inquiry实现

```java
@Override
public int inquiry(int route, int departure, int arrival) {
    if (isParamsInvalid(route, departure, arrival)) {
        return -1;
    }
    // 保证内存可见性
    readStatus(route);
    int res = 0;
    long[] seatsForRoute = longArray[route - 1];
    for (long l : seatsForRoute) {
        res += getCorrespondSeatCount(l, departure, arrival, false);
    }
    res -= seatsPerLong - COACH_NUM * SEAT_NUM % seatsPerLong;
    return res;
}
```

##### 正确性与性能

与实现三一样，遍历全部的座位信息。

##### 满足要求

- Lock-free: $\checkmark$

- Wait-free: $\checkmark$



#### BuyTicket实现

```java
@Override
public Ticket buyTicket(String passenger, int route, int departure, int arrival) {
    readStatus(route);
    if (isParamsInvalid(route, departure, arrival)) {
        return null;
    }
    long[] seatsForRoute = longArray[route - 1];

    int[] crowdParts = crowd[route - 1].clone();
    Map<Integer, Integer> m = new HashMap<>();
    for (int i = 0; i < crowdParts.length; i++) {
        m.put(crowdParts[i], i);
    }
    Arrays.sort(crowdParts);

    int boughtSeatIdxOnRoute = -1;
    int boughtInPart = -1;
    for (int i = crowdParts.length - 1; i >= 0; i--) {
        ThreadLocalRandom random = ThreadLocalRandom.current();
        int partIdx = m.get(crowdParts[i]);
        int left = partIdx * seatsPerPart / seatsPerLong;
        int right = (partIdx + 1) * seatsPerPart / seatsPerLong;
        if (partIdx == crowdParts.length - 1) {
            right++;
        }
        int startIdx = random.nextInt(left, Math.min(seatsForRoute.length, right));
        int currIdx = startIdx;
        while (currIdx >= left) {
            boughtSeatIdxOnRoute = trySetOccupied(route, currIdx, departure, arrival, true);
            if (boughtSeatIdxOnRoute != -1) {
                boughtInPart = partIdx;
                break;
            }
            currIdx--;
        }
        if (boughtSeatIdxOnRoute == -1) {
            currIdx = startIdx + 1;
            while (currIdx < right) {
                boughtSeatIdxOnRoute = trySetOccupied(route, currIdx, departure, arrival, true);
                if (boughtSeatIdxOnRoute != -1) {
                    boughtInPart = partIdx;
                    break;
                }
                currIdx++;
            }
        }
        if (boughtSeatIdxOnRoute != -1) {
            break;
        }
    }
    if (boughtSeatIdxOnRoute == -1) {
        // 无余票
        return null;
    }
    assert boughtInPart != -1;
    Seat s = new Seat(route, boughtSeatIdxOnRoute);
    crowd[route - 1][boughtInPart] -= (arrival - departure + 1);
    return buildTicket(getCurrThreadNextTid(), passenger, route, s.getCoach(), s.getSeat(), departure, arrival);
}
```

写入座位使用了以下方法：

```java
protected int trySetOccupied(int route, int seatContainerElemIdx, int departure, int arrival, boolean tryWithLoop) {
    long expectedSeatInfo, newSeatInfo;
    long[] seatsForRoute = longArray[route - 1];
    for (; ; ) {
        expectedSeatInfo = seatsForRoute[seatContainerElemIdx];
        newSeatInfo = expectedSeatInfo;
        long[] masks = dep2arr2posMasks[departure - 1][arrival - 1];
        boolean found = false;
        int seatPos = -1;
        for (int i = 0; i < masks.length; i++) {
            if (seatContainerElemIdx == seatsForRoute.length - 1) {
                if ((seatsForRoute.length - 1) * seatsPerLong + i + 1 > COACH_NUM * SEAT_NUM) {
                    // 数组最后一位，可能会多出一些座位来。防止在他们上购买。
                    break;
                }
            }
            long mask;
            // ones mask
            if (0 == (expectedSeatInfo & (mask = masks[i]))) {
                newSeatInfo |= mask;
                found = true;
                seatPos = i;
                break;
            }
        }
        if (!found) {
            return -1;
        }
        boolean fail = !vh.compareAndSet(longArray[route - 1], seatContainerElemIdx, expectedSeatInfo, newSeatInfo);
        if (!fail) {
            writeStatus(route);
            return seatContainerElemIdx * seatsPerLong + seatPos;
        }
        if (!tryWithLoop) {
            return seatContainerElemIdx * seatsPerLong + seatPos;
        }
    }
}
```

##### 正确性与性能

在实现三的基础上进行了改进。使用了热点区域crowdParts的思想。对于一个车次里的全部座位，将它们划分成多个区域。每个区域的座位数量在一开始是满的。一旦当购票后，该区域的座位数量便减少一部分。可以统计得到每个区域的座位数量。从座位数量最多的区域开始搜索，能够尽可能加速购票的速度。但是对于这个每个区域的座位数量数组，没有采取高开销的原子操作，使用普通的操作即可。随后这个数组可能并不准确，但是性能足够快。

写入数据使用了位图mask，性能较快。

##### 满足要求

与实现三一致。

- Lock-free: $\checkmark$

#### RefundTicket实现

```java
@Override
public boolean refundTicket(Ticket ticket) {
    if (isParamsInvalid(ticket.route, ticket.departure, ticket.arrival)) {
        return false;
    }
    Seat seat = new Seat(ticket.route, ticket.coach, ticket.seat);
    boolean suc = freeOccupiedForSpecificSeat(ticket.route, seat.getSeatContainerElemIdx(), seat.getSeatPosInContainerElem(), ticket.departure, ticket.arrival, true);
    crowd[ticket.route - 1][seat.getSeatIdxOnRoute() / (seatsPerPart)] += (ticket.arrival - ticket.departure + 1);
    return suc;
}
```

释放座位使用了以下方法：

```java
protected boolean freeOccupiedForSpecificSeat(int route, int seatContainerElemIdx, int seatPosInContainerElem, int departure, int arrival, boolean tryWithLoop) {
    long expectedSeatInfo, newSeatInfo;
    long[] seatsForRoute = longArray[route - 1];
    for (; ; ) {
        expectedSeatInfo = seatsForRoute[seatContainerElemIdx];
        newSeatInfo = expectedSeatInfo;
        long[] masks = dep2arr2posMasks[departure - 1][arrival - 1];
        long onesMask = masks[seatPosInContainerElem];
        if (onesMask == (expectedSeatInfo & onesMask)) {
            newSeatInfo &= ~onesMask;
        } else {
            // 不符合要求
            return false;
        }
        boolean fail = !vh.compareAndSet(longArray[route - 1], seatContainerElemIdx, expectedSeatInfo, newSeatInfo);
        if (!fail) {
            writeStatus(route);
            return true;
        }
        if (!tryWithLoop) {
            return false;
        }
    }
}
```

##### 正确性与性能

在释放座位后，将crowd区域的座位数增加。

由于使用了压缩存储的位图，性能相对较好。

##### 满足要求

Lock-free: $\checkmark$

### 实现七

继承了实现六，但是仍然采取了随机选取座位的方式。

#### BuyTicket与RefundTicket实现

```java
@Override
public Ticket buyTicket(String passenger, int route, int departure, int arrival) {
    readStatus(route);
    if (isParamsInvalid(route, departure, arrival)) {
        return null;
    }
    ThreadLocalRandom random = ThreadLocalRandom.current();
    long[] seatsForRoute = longArray[route - 1];
    int startIdx = random.nextInt(seatsForRoute.length);

    int currIdx = startIdx;
    int boughtSeatIdxOnRoute = -1;
    while (currIdx >= 0) {
        boughtSeatIdxOnRoute = trySetOccupied(route, currIdx, departure, arrival, true);
        if (boughtSeatIdxOnRoute != -1) {
            break;
        }
        currIdx--;
    }
    if (boughtSeatIdxOnRoute == -1) {
        currIdx = startIdx + 1;
        while (currIdx < seatsForRoute.length) {
            boughtSeatIdxOnRoute = trySetOccupied(route, currIdx, departure, arrival, true);
            if (boughtSeatIdxOnRoute != -1) {
                break;
            }
            currIdx++;
        }
    }
    if (boughtSeatIdxOnRoute == -1) {
        // 无余票
        return null;
    }
    Seat s = new Seat(route, boughtSeatIdxOnRoute);
    return buildTicket(getCurrThreadNextTid(), passenger, route, s.getCoach(), s.getSeat(), departure, arrival);
}

@Override
public boolean refundTicket(Ticket ticket) {
    if (isParamsInvalid(ticket.route, ticket.departure, ticket.arrival)) {
        return false;
    }
    Seat seat = new Seat(ticket.route, ticket.coach, ticket.seat);
    return freeOccupiedForSpecificSeat(ticket.route, seat.getSeatContainerElemIdx(), seat.getSeatPosInContainerElem(), ticket.departure, ticket.arrival, true);
}
```

##### 满足要求

Lock-free: $\checkmark$



### 实现八

继承了实现七，在选取座位上使用了实现四中使用的方法。买票时首先查看最近刚刚退掉票的座位。

#### BuyTicket与RefundTicket实现

```java
@Override
public Ticket buyTicket(String passenger, int route, int departure, int arrival) {
    readStatus(route);
    if (isParamsInvalid(route, departure, arrival)) {
        return null;
    }

    int currIdx;
    int boughtSeatIdxOnRoute = -1;

    Map<Integer, List<Integer>> mapSeatIdxes = justRefundSeatContainerElemIdxes.get();
    List<Integer> seatIdxes = mapSeatIdxes == null ? null : mapSeatIdxes.get(route);
    while (seatIdxes != null && seatIdxes.size() > 0) {
        currIdx = seatIdxes.remove(seatIdxes.size() - 1);
        boughtSeatIdxOnRoute = trySetOccupied(route, currIdx, departure, arrival, true);
        if (boughtSeatIdxOnRoute != -1) {
            break;
        }
    }

    ThreadLocalRandom random = ThreadLocalRandom.current();
    long[] seatsForRoute = longArray[route - 1];
    int startIdx = random.nextInt(seatsForRoute.length);

    if (boughtSeatIdxOnRoute == -1) {
        int count = 0;
        currIdx = startIdx;
        while (count < seatsForRoute.length) {
            count++;
            boughtSeatIdxOnRoute = trySetOccupied(route, currIdx, departure, arrival, true);
            if (boughtSeatIdxOnRoute != -1) {
                break;
            }
            currIdx = (currIdx + 1) % seatsForRoute.length;
        }
    }
    if (boughtSeatIdxOnRoute == -1) {
        // 无余票
        return null;
    }
    Seat s = new Seat(route, boughtSeatIdxOnRoute);
    return buildTicket(getCurrThreadNextTid(), passenger, route, s.getCoach(), s.getSeat(), departure, arrival);
}

@Override
public boolean refundTicket(Ticket ticket) {
    if (isParamsInvalid(ticket.route, ticket.departure, ticket.arrival)) {
        return false;
    }
    Seat seat = new Seat(ticket.route, ticket.coach, ticket.seat);
    boolean suc = freeOccupiedForSpecificSeat(ticket.route, seat.getSeatContainerElemIdx(), seat.getSeatPosInContainerElem(), ticket.departure, ticket.arrival, true);
    if (suc) {
        if (justRefundSeatContainerElemIdxes.get() == null) {
            justRefundSeatContainerElemIdxes.set(new HashMap<>());
            for (int i = 0; i < ROUTE_NUM; i++) {
                justRefundSeatContainerElemIdxes.get().put(i + 1, new ArrayList<>(longArray[i].length));
            }
        }
        if (ticket.arrival - ticket.departure >= STATION_NUM / 2)
            justRefundSeatContainerElemIdxes.get().get(ticket.route).add(seat.seatContainerElemIdx);
    }
    return suc;
}
```

##### 满足要求

Lock-free: $\checkmark$





### 实现九

实现九实现了一个异步的架构，它不能在同步调用的条件下使用，所以不符合本题目的需求，但是在这里还是给出思考过程。

继承了实现六，为整体座位的占用情况构建了一个视图（view）。该view精准存出来每个站点的空闲座位数量。这样在查询时，直接遍历站点，选取其中最小的座位数，就是查询结果。这样能够加速查询。

但是维护这样的视图需要使用一个AtomicReference存储一个数组，那么如果在Buy或Refund之后直接进行CAS会造成极大的热点访问问题，效率极差。所以想到了通过后台线程维护这个视图。当购买（退票）结束后，告知后台线程更新了数据，后台线程再异步修改视图。但这样就无法保证查询能够立即可见。所以这是一个异步的实现。

以下给出了部分实现代码。

```java
private class ImplNine extends ImplSix implements Closeable {

    public ImplNine() {
        super();
        initViews();
        initThreadPool();
    }

    protected AtomicBoolean shutdownThreadPool = new AtomicBoolean(false);

    protected class SetViewTask {
        int route;
        int departure;
        int arrival;
        boolean occupied;

        public SetViewTask(int route, int departure, int arrival, boolean occupied) {
            this.route = route;
            this.departure = departure;
            this.arrival = arrival;
            this.occupied = occupied;
        }
    }

    protected BlockingQueue<SetViewTask>[] offsets = new LinkedBlockingQueue[THREAD_NUM];

    protected void initThreadPool() {
        for (int i = 0; i < offsets.length; i++) {
            offsets[i] = new LinkedBlockingQueue<>();
        }
        for (int i = 0; i < THREAD_NUM; i++) {
            int ic = i;
            new Thread(() -> {
                SetViewTask t;
                while ((t = offsets[ic].poll()) != null || !shutdownThreadPool.get()) {
                    try {
                        if (t == null) {
                            t = offsets[ic].poll(10, TimeUnit.MILLISECONDS);
                        }
                        if (t == null) {
                            Thread.sleep(5);
                            continue;
                        }
                        setView(t.route, t.departure, t.arrival, t.occupied);
                    } catch (InterruptedException e) {
                        //
                    }
                }
            }).start();
        }
    }

    protected AtomicInteger currMappedThreadID = new AtomicInteger(0);
    protected ThreadLocal<Integer> mappedThreadID = new ThreadLocal<>();

    protected int getMappedThreadID() {
        Integer mapped;
        if ((mapped = mappedThreadID.get()) != null) {
            return mapped;
        }
        mapped = currMappedThreadID.getAndIncrement();
        mappedThreadID.set(mapped);
        return mapped;
    }

    protected void submitToThreadPool(SetViewTask t) {
        int mapped = getMappedThreadID();
        offsets[mapped].offer(t);
    }

    @Override
    public void close() throws IOException {
        shutdownThreadPool.set(true);
    }

    @Override
    public int inquiry(int route, int departure, int arrival) {
        if (isParamsInvalid(route, departure, arrival)) {
            return -1;
        }
        return readEmptyView(route, departure, arrival);
    }

    @Override
    public Ticket buyTicket(String passenger, int route, int departure, int arrival) {
        if (isParamsInvalid(route, departure, arrival)) {
            return null;
        }
        ThreadLocalRandom random = ThreadLocalRandom.current();
        long[] seatsForRoute = longArray[route - 1];
        int startIdx = random.nextInt(seatsForRoute.length);

        int currIdx = startIdx;
        int boughtSeatIdxOnRoute = -1;
        while (currIdx >= 0) {
            boughtSeatIdxOnRoute = trySetOccupied(route, currIdx, departure, arrival, true);
            if (boughtSeatIdxOnRoute != -1) {
                break;
            }
            currIdx--;
        }
        if (boughtSeatIdxOnRoute == -1) {
            currIdx = startIdx + 1;
            while (currIdx < seatsForRoute.length) {
                boughtSeatIdxOnRoute = trySetOccupied(route, currIdx, departure, arrival, true);
                if (boughtSeatIdxOnRoute != -1) {
                    break;
                }
                currIdx++;
            }
        }
        if (boughtSeatIdxOnRoute == -1) {
            // 无余票
            return null;
        }
        submitToThreadPool(new SetViewTask(route, departure, arrival, true));
        Seat s = new Seat(route, boughtSeatIdxOnRoute);
        return buildTicket(getCurrThreadNextTid(), passenger, route, s.getCoach(), s.getSeat(), departure, arrival);
    }
  
    @Override
    public boolean refundTicket(Ticket ticket) {
        if (isParamsInvalid(ticket.route, ticket.departure, ticket.arrival)) {
            return false;
        }
        Seat seat = new Seat(ticket.route, ticket.coach, ticket.seat);
        boolean suc = freeOccupiedForSpecificSeat(ticket.route, seat.getSeatContainerElemIdx(), seat.getSeatPosInContainerElem(), ticket.departure, ticket.arrival, true);
        if (suc) {
            submitToThreadPool(new SetViewTask(ticket.route, ticket.departure, ticket.arrival, false));
        }
        return suc;
    }

}
```



### 实现十

由于在实现九中考虑到使用后台线程维护数据的方案，于是想到了通过后台线程能够维护一个空闲座位分布的数据结构。由于空闲座位的分布并不一定要求准确，所以即使异步更新也能保证程序的正确性。

#### 空闲座位分布存储

使用如下的availableSeats三维数组存储空闲座位的分布情况，这种方案使用了大量的存储空间。

```java
// route -> departure -> arrival -> ConcurrentHashMap
protected Map<Integer, Boolean>[][][] availableSeats = new Map[ROUTE_NUM][STATION_NUM][STATION_NUM];

protected void initAvailableSeats() {
    for (int i = 0; i < availableSeats.length; i++) {
        availableSeats[i] = new Map[STATION_NUM][STATION_NUM];
        for (int j = 0; j < STATION_NUM - 1; j++) {
            availableSeats[i][j] = new Map[STATION_NUM];
            for (int k = j + 1; k < STATION_NUM; k++) {
                availableSeats[i][j][k] = new ConcurrentHashMap<>();
            }
        }
    }
    for (int seatIdx = 0; seatIdx < intArray.length; seatIdx++) {
        Seat s = new Seat(seatIdx);

        for (int dep = 0; dep < STATION_NUM - 1; dep++) {
            for (int arr = dep + 1; arr < STATION_NUM; arr++) {
                availableSeats[s.getRoute() - 1][dep][arr].put(s.getSeatIdx(), true);
            }
        }
    }
}
```

#### 空闲座位数据维护

使用如下方法对空闲座位进行维护，后台线程调用该方法。

```java
protected void rePutAvailableSeat(int seatIdx) {
    Seat s = new Seat(seatIdx);
    int seatInfo = (Integer) vh.getOpaque(intArray, seatIdx);
    DepArr[] emptyParts = extractEmptyParts(seatInfo);
    for (int dep = 0; dep < STATION_NUM - 1; dep++) {
        nextArr:
        for (int arr = dep + 1; arr < STATION_NUM; arr++) {
            for (DepArr emptyPart : emptyParts) {
                if (emptyPart == null) {
                    break;
                }
                if (emptyPart.hold(dep, arr)) {
                    availableSeats[s.getRoute() - 1][dep][arr].put(seatIdx, true);
                    continue nextArr;
                }
            }
            // cannot hold
            availableSeats[s.getRoute() - 1][dep][arr].remove(seatIdx);
        }
    }
}
```

#### 线程池

使用每个请求线程一对一的方案，尽量减少线程间通讯的overhead。

```java
protected BlockingQueue<Integer>[] rePuts = new BlockingQueue[THREAD_NUM];

protected void initThreadPool() {
    for (int i = 0; i < rePuts.length; i++) {
        rePuts[i] = new LinkedBlockingQueue<>();
    }
    for (int i = 0; i < THREAD_NUM; i++) {
        int ic = i;
        new Thread(() -> {
            while (!shutdownThreadPool.get()) {
                try {
                    Integer seatIdx = rePuts[ic].poll(10, TimeUnit.MILLISECONDS);
                    if (seatIdx == null) {
                        continue;
                    }
                    rePutAvailableSeat(seatIdx);
                } catch (InterruptedException e) {
                    break;
                }
            }
        }).start();
    }
}
```

#### 正确性分析与满足要求

只变更了购买时查询座位的顺序，分析与实现三一致。



### 实现十一

实现十一继承了实现四，在已有方案的基础上，考虑到了数据本地性的问题。之前的搜索策略都是在整个座位的分布数组上进行随机搜索。在本实现中，将座位分布数组划分为多份，每个线程分配一个固定的搜索顺序，从某个固定的划分区域开始搜索。这样一来，每个线程每次都会从它对应的区域开始搜索，提高了缓存命中率。

#### 数组分块

默认使用COACH_NUM作为分区数量。

```java
protected int partsCount = COACH_NUM;

protected int partLength = COACH_NUM * SEAT_NUM / partsCount;
```

#### 固定线程映射

使用AtomicInteger以及ThreadLocal的mappedThreadID为每个线程分配一个从0开始增长的固定的ID。

```java
protected AtomicInteger currMappedThreadID = new AtomicInteger(0);
protected ThreadLocal<Integer> mappedThreadID = new ThreadLocal<>();

protected int getMappedThreadID() {
    Integer mapped;
    if ((mapped = mappedThreadID.get()) != null) {
        return mapped;
    }
    mapped = currMappedThreadID.getAndIncrement();
    mappedThreadID.set(mapped);
    return mapped;
}
```

#### BuyTicket

在购票时，从固定的part开始

```java
int currPart = getMappedThreadID() % partsCount;
// ...
for (int i = 0; i < partsCount; i++) {
    int left = (route - 1) * COACH_NUM * SEAT_NUM + currPart * partLength;
    // int right = route * COACH_NUM * SEAT_NUM - 1;
    int right = Math.min(route * COACH_NUM * SEAT_NUM - 1, (route - 1) * COACH_NUM * SEAT_NUM + (currPart + 1) * partLength);
    boughtIdx = tryBuyWithInRange(route, departure, arrival, left, right, random);
    if (boughtIdx != -1) {
        break;
    }
    currPart = (currPart + 1) % partsCount;
}
```

#### 正确性分析与满足要求

只变更了购买时查询座位的顺序，分析与实现四一致。



### 实现十二

与实现十一的思路完全一致，只不过它是在实现六的压缩后的数据结构上实现的。

同样将在自己的固定的分区上优先开始搜索。

```java
int currPart = getMappedThreadID() % partsCount;
long[] seatsForRoute = longArray[route - 1];
for (int i = 0; i < partsCount; i++) {
    int left = currPart * partLength;
    // int right = route * COACH_NUM * SEAT_NUM - 1;
    int right = Math.min(seatsForRoute.length - 1, (currPart + 1) * partLength);
    boughtSeatIdxOnRoute = tryBuyWithInRange(route, departure, arrival, left, right, random);
    if (boughtSeatIdxOnRoute != -1) {
        break;
    }
    currPart = (currPart + 1) % partsCount;
}
```

#### 正确性分析与满足要求

只变更了购买时查询座位的顺序，分析与实现六一致。





### 实现十三/十四

分别在前面两类数据结构中实现了不区分座位的视图形式的实现。具体含义为：不关心顾客坐在哪里，只知道每个车次的剩余容量。仅保存从某站到某站的剩余位置数量。在这里不满足题目要求，所以仅作为参考。

```java
public class ThreadLocalViewHelper {

    private final TicketingDS.TicketingDSParam param;

    public ThreadLocalViewHelper(TicketingDS.TicketingDSParam param) {
        this.param = param;
        this.threadLocalView = new int[param.THREAD_NUM][param.STATION_NUM];
        initThreadLocalView();
    }

    protected int[][] threadLocalView;

    protected void initThreadLocalView() {
        for (int i = 0; i < param.THREAD_NUM; i++) {
            threadLocalView[i] = new int[param.STATION_NUM];
            Arrays.fill(threadLocalView[i], param.SEAT_NUM * param.COACH_NUM);
        }
    }

    protected void updateView(int mappedTheadID, int route, int departure, int arrival, boolean add) {
        int offset = add ? 1 : -1;
        for (int i = departure - 1; i <= arrival - 1; i++) {
            threadLocalView[mappedTheadID][i] += offset;
        }
    }

    public int inquiryHelper(int route, int departure, int arrival) {
        int res = param.SEAT_NUM * param.COACH_NUM;
        for (int i = 0; i < param.THREAD_NUM; i++) {
            int min = Integer.MAX_VALUE;
            for (int j = departure - 1; j <= arrival - 1; j++) {
                min = Math.min(threadLocalView[i][j], min);
            }
            res -= min;
        }
        return param.SEAT_NUM * param.COACH_NUM - res;
    }
}
```



### 实现十五/十六

分别在前面的两种数据结构中，利用jdk最新的vector指令向量化的功能，对inquiry进行加速。

```java
public class VectorizedHelper {
    static final VectorSpecies<Integer> INTEGER_VECTOR_SPECIES = IntVector.SPECIES_PREFERRED;
    static final VectorSpecies<Long> LONG_VECTOR_SPECIES = LongVector.SPECIES_PREFERRED;

    // 向量化的整数数组运算。
    // 这个运算对于data中的每个元素，对它与mask进行相与，计算相与之后不为0的元素个数。
    // 实际上就是计算出了座位不为空的元素个数。
    static int intVectorMasked(int[] data, int mask) {
        int i = 0;
        int upperBound = INTEGER_VECTOR_SPECIES.loopBound(data.length);
        int sum = 0;
        for (; i < upperBound; i += INTEGER_VECTOR_SPECIES.length()) {
            var va = IntVector.fromArray(INTEGER_VECTOR_SPECIES, data, i);
            sum += va.and(mask).compare(VectorOperators.NE, 0).trueCount();
        }
        for (; i < data.length; i++) {
            if ((data[i] & mask) != 0) {
                sum++;
            }
        }
        return sum;
    }

    static int longMultiVectorsMasked(long[] data, long[] masks) {
        int i = 0;
        int upperBound = LONG_VECTOR_SPECIES.loopBound(data.length);
        int sum = 0;
        for (; i < upperBound; i += LONG_VECTOR_SPECIES.length()) {
            var va = LongVector.fromArray(LONG_VECTOR_SPECIES, data, i);
            for (long mask : masks) {
                sum += va.and(mask).compare(VectorOperators.NE, 0).trueCount();
            }
        }
        for (; i < data.length; i++) {
            for (long mask : masks) {
                if ((data[i] & mask) != 0) {
                    sum++;
                }
            }
        }
        return sum;
    }

}
```



### 总结

| Inquiry         | 实现一       | 实现二       | 实现三至十六 |
| --------------- | ------------ | ------------ | ------------ |
| Deadlock-free   |              | $\checkmark$ |              |
| Starvation-free |              |              |              |
| Lock-free       | $\checkmark$ |              | $\checkmark$ |
| Wait-free       | $\checkmark$ |              | $\checkmark$ |

| BuyTicket       | 实现一       | 实现二       | 实现三至十六 |
| --------------- | ------------ | ------------ | ------------ |
| Deadlock-free   | $\checkmark$ | $\checkmark$ |              |
| Starvation-free |              |              |              |
| Lock-free       |              |              | $\checkmark$ |
| Wait-free       |              |              |              |

| RefundTicket    | 实现一       | 实现二       | 实现三至十六 |
| --------------- | ------------ | ------------ | ------------ |
| Deadlock-free   | $\checkmark$ | $\checkmark$ |              |
| Starvation-free |              |              |              |
| Lock-free       |              |              | $\checkmark$ |
| Wait-free       |              |              |              |



## 多线程测试程序的设计思路

### TicketingDS内部对于测试的支持

TicketingDS内部有定义一个enum，如下所示：

```java
public enum ImplType {
    One(ImplOne.class),
    Two(ImplTwo.class),
    Three(ImplThree.class),
    Four(ImplFour.class),
    Five(ImplFive.class),
    Six(ImplSix.class),
    Seven(ImplSeven.class);
    private final Class<? extends TicketingSystem> implClass;

    ImplType(Class<? extends TicketingSystem> implClass) {
        this.implClass = implClass;
    }
}
```

该枚举内部包含了七个内部的实现TicketingSystem接口的类。即上面所说的实现一到七。

通过使用如下所示的switchImplType方法，使用java的反射，动态更改TicketingDS的实现类，提供方便地动态测试能力。

```java
public void switchImplType(ImplType type) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {
    this.actualImpl = type.implClass.getConstructor(TicketingDS.class).newInstance(this);
    this.soldTickIds = new ThreadLocal<>();
    this.currTid = new ThreadLocal<>();
    this.nextTidRegion = new AtomicInteger();
    this.currTidRegion = new ThreadLocal<>();
}
```

### Test类实现

首先定义常量以及部分类变量

```java
private static final int INQUIRY_RATIO = 70;
private static final int PURCHASE_RATIO = 20;
private static final int REFUND_RATIO = 10;

private static final int ROUTE_NUM = 10;
private static final int COACH_NUM = 8;
private static final int SEAT_NUM = 100;
private static final int STATION_NUM = 10;
private static final int FUNC_CALL_COUNT = 100000;

private static int THREAD_NUM = 16;

private static final int REPEAT_MULTI_THREAD_TEST_COUNT = 5;
```

其中thread2Statistics存储当每个线程运行结束后，存储的统计数据。

其代表统计数据的类为TicketConsumerStatistics，如下所示：

```java
private static class TicketConsumerStatistics {
    private int tryBuyCount = 0;
    private int tryInqCount = 0;
    private int tryRefCount = 0;
    private long buyExecTime = 0;
    private long inqExecTime = 0;
    private long refExecTime = 0;
    private int funcCallCount = 0;
    private long fullExecTime = 0;
    ...
}
```

分别对应存储了每个操作的执行次数，以及执行时间。

##### 开始测试的入口

```java
private static void doVariousThreadNumMultiThreadTest() throws ... {
    int[] THREAD_NUMS = new int[]{4, 8, 16, 32, 64};
    for (int thread_num : THREAD_NUMS) {
        System.out.println("-------------- START TEST THREAD NUM = " + thread_num + " --------------");
        THREAD_NUM = thread_num;
        tds = new TicketingDS(ROUTE_NUM, COACH_NUM, SEAT_NUM, STATION_NUM, THREAD_NUM);
        for (TicketingDS.ImplType value : TicketingDS.ImplType.values()) {
            repeatDoMultiThreadTest(value, REPEAT_MULTI_THREAD_TEST_COUNT);
        }
        System.out.println("--------------- END TEST THREAD NUM = " + thread_num + " ---------------\n\n");
    }
}
```

对于4，8，16，32，64个线程，分别repeatDoMultiThreadTest进行测试，该函数接受一个repeatCount参数，表示一共重复执行repeatCount次测试后，取其中位数测试结果。

以下定义了repeatDoMultiThreadTest：

```java
private static void repeatDoMultiThreadTest(TicketingDS.ImplType implType, int repeatCount) throws InterruptedException, InvocationTargetException, NoSuchMethodException, InstantiationException, IllegalAccessException {
    thread2Statistics = new ConcurrentHashMap<>();
    for (int i = 0; i < THREAD_NUM; i++) {
        thread2Statistics.put(String.valueOf(i + 1), new TicketConsumerStatistics());
    }
    long[] fullElapsedTimes = new long[repeatCount];
    for (int i = 0; i < repeatCount; i++) {
        tds.switchImplType(implType);
        Thread[] threads = new Thread[THREAD_NUM];
        for (int j = 0; j < THREAD_NUM; j++) {
            Thread t = new Thread(new TicketConsumerRunner(), String.valueOf(j + 1));
            threads[j] = t;
        }
        long start = System.nanoTime();
        for (Thread thread : threads) {
            thread.start();
        }
        for (Thread thread : threads) {
            thread.join();
        }
        long fullElapsedTime = System.nanoTime() - start;
        fullElapsedTimes[i] = fullElapsedTime;
    }

    long minFullElapsedTime = Arrays.stream(fullElapsedTimes).min().getAsLong();

    long avgExecNanoTime = (long) thread2Statistics.values().stream().mapToLong(TicketConsumerStatistics::getFullExecTime).average().getAsDouble();
    long fullBuyExecNanoTime = thread2Statistics.values().stream().mapToLong(TicketConsumerStatistics::getBuyExecTime).sum();
    long fullInqExecNanoTime = thread2Statistics.values().stream().mapToLong(TicketConsumerStatistics::getInqExecTime).sum();
    long fullRefExecNanoTime = thread2Statistics.values().stream().mapToLong(TicketConsumerStatistics::getRefExecTime).sum();

    int fullFuncCallCount = thread2Statistics.values().stream().mapToInt(TicketConsumerStatistics::getFuncCallCount).sum();
    int avgFuncCallCount = (int) (thread2Statistics.values().stream().mapToInt(TicketConsumerStatistics::getFuncCallCount).average().getAsDouble());
    int fullBuyFuncCallCount = thread2Statistics.values().stream().mapToInt(TicketConsumerStatistics::getTryBuyCount).sum();
    int fullInqFuncCallCount = thread2Statistics.values().stream().mapToInt(TicketConsumerStatistics::getTryInqCount).sum();
    int fullRefFuncCallCount = thread2Statistics.values().stream().mapToInt(TicketConsumerStatistics::getTryRefCount).sum();

    double throughPut_nano = (1. * fullFuncCallCount / repeatCount) / minFullElapsedTime;
    double throughPut_withAvgExecNanoTime = THREAD_NUM * (1. * avgFuncCallCount) / (avgExecNanoTime);
    System.out.println("====================================================================");
    System.out.printf("%s class repeat multi thread test finished.\n", tds.getImplClass().getSimpleName());
    System.out.println("repeat test count: " + repeatCount);
    System.out.println("minFullElapsedTime = " + minFullElapsedTime);
    System.out.printf("fullFuncCallCount = %d, avgFuncCallCount = %d, avgExecNanoTime = %d\n", fullFuncCallCount, avgFuncCallCount, avgExecNanoTime);
    System.out.println("throughPut(func/nano) = " + throughPut_nano);
    System.out.println("throughPut_withAvgExecNanoTime(func/nano) = " + throughPut_withAvgExecNanoTime);
    System.out.println("inquiry average exec time = " + 1. * fullInqExecNanoTime / fullInqFuncCallCount);
    System.out.println("buyTicket average exec time = " + 1. * fullBuyExecNanoTime / fullBuyFuncCallCount);
    System.out.println("refundTicket average exec time = " + 1. * fullRefExecNanoTime / fullRefFuncCallCount);
    System.out.println("====================================================================\n");
}
```

启动THREAD_NUM个线程，其执行Runner为TicketConsumerRunner，在其内部再进行具体的tds操作调用。

在最后，将统计数据内部的数据进行stream处理，统计方法执行总数，执行时间等等数据，最后再进行打印屏幕的操作。

重复repeatCount次实验，每一次记录一个fullElapsedTime。最终取执行最快的一次计算吞吐量。

TicketConsumerRunner内部较为简单，逻辑即为按照ThreadLocalRandom提供的随机数，选择执行inquiry，buyTicket以及refundTicket操作，在执行次数结束后，将执行过程中统计的执行次数与执行时间添加到线程安全的thread2Statistics中即可。



## 执行效率测试结果

### 执行环境

服务器上进行执行

### 执行配置

```java
private static final int INQUIRY_RATIO = 70; 										// Inquiry比例
private static final int PURCHASE_RATIO = 20;										// BuyTicket比例
private static final int REFUND_RATIO = 10;  										// RefundTicket比例
private static final int ROUTE_NUM = 10;      										// 车次
private static final int COACH_NUM = 8;													// 车厢
private static final int SEAT_NUM = 100;												// 每个车厢的座位
private static final int STATION_NUM = 10;										  // 车站数量
private static final int FUNC_CALL_COUNT = 100000;								// 函数调用次数
private static final int REPEAT_MULTI_THREAD_TEST_COUNT = 5;  // 重复测试次数
```

### 输出结果实例

``` 
-------------- START TEST THREAD NUM = 4 --------------
Thread Num = 4
====================================================================
ImplOne class repeat multi thread test finished.
repeat test count: 5
minFullElapsedTimePerEpoch = 74615776, maxFullElapsedTimePerEpoch = 440117742
avgFullElapsedTimePerEpoch = 161039958, midFullElapsedTimePerEpoch = 97741378
minFullElapsedTimeInnerPerEpoch = 73246359, maxFullElapsedTimeInnerPerEpoch = 435810040
avgFullElapsedTimeInnerPerEpoch = 159534113, midFullElapsedTimeInnerPerEpoch = 97207036
fullFuncCallCount = 2000000, avgFuncCallCount = 500000
best_throughPut(func/nano) = 0.005360796622955446
mid_throughput(func/nano) = 0.004092432582646829
avg_throughPut(func/nano) = 0.00248385559067272
best_throughPut_inner(func/nano) = 0.005360796622955446
avg_throughPut_inner(func/nano) = 0.0025073007426317656
inquiry average exec time = 853.5128570428301
buyTicket average exec time = 2427.816964743742
refundTicket average exec time = 1559.3076394319614
====================================================================

====================================================================
ImplTwo class repeat multi thread test finished.
repeat test count: 5
minFullElapsedTimePerEpoch = 77887936, maxFullElapsedTimePerEpoch = 192514358
avgFullElapsedTimePerEpoch = 109844893, midFullElapsedTimePerEpoch = 86045246
minFullElapsedTimeInnerPerEpoch = 77111303, maxFullElapsedTimeInnerPerEpoch = 191324372
avgFullElapsedTimeInnerPerEpoch = 108819963, midFullElapsedTimeInnerPerEpoch = 85292311
fullFuncCallCount = 2000000, avgFuncCallCount = 500000
best_throughPut(func/nano) = 0.005135583513215705
mid_throughput(func/nano) = 0.0046487170249940365
avg_throughPut(func/nano) = 0.003641498380812297
best_throughPut_inner(func/nano) = 0.005135583513215705
avg_throughPut_inner(func/nano) = 0.0036757961404563244
inquiry average exec time = 439.2956602466597
buyTicket average exec time = 2045.9792243594072
refundTicket average exec time = 1985.803854098418
====================================================================

====================================================================
ImplThree class repeat multi thread test finished.
repeat test count: 5
minFullElapsedTimePerEpoch = 160304734, maxFullElapsedTimePerEpoch = 378421210
avgFullElapsedTimePerEpoch = 218118052, midFullElapsedTimePerEpoch = 187731805
minFullElapsedTimeInnerPerEpoch = 159824553, maxFullElapsedTimeInnerPerEpoch = 377163400
avgFullElapsedTimeInnerPerEpoch = 217150502, midFullElapsedTimeInnerPerEpoch = 186482135
fullFuncCallCount = 2000000, avgFuncCallCount = 500000
best_throughPut(func/nano) = 0.00249524758264469
mid_throughput(func/nano) = 0.002130699164161342
avg_throughPut(func/nano) = 0.0018338693030322865
best_throughPut_inner(func/nano) = 0.00249524758264469
avg_throughPut_inner(func/nano) = 0.001842040411216733
inquiry average exec time = 1998.8853984014497
buyTicket average exec time = 2454.295699596291
refundTicket average exec time = 678.414218208338
====================================================================

====================================================================
ImplFour class repeat multi thread test finished.
repeat test count: 5
minFullElapsedTimePerEpoch = 153052373, maxFullElapsedTimePerEpoch = 207042970
avgFullElapsedTimePerEpoch = 176622933, midFullElapsedTimePerEpoch = 170286768
minFullElapsedTimeInnerPerEpoch = 152661409, maxFullElapsedTimeInnerPerEpoch = 206487936
avgFullElapsedTimeInnerPerEpoch = 176118871, midFullElapsedTimeInnerPerEpoch = 169921956
fullFuncCallCount = 2000000, avgFuncCallCount = 500000
best_throughPut(func/nano) = 0.00261348447044333
mid_throughput(func/nano) = 0.0023489787532992583
avg_throughPut(func/nano) = 0.00226471157060901
best_throughPut_inner(func/nano) = 0.00261348447044333
avg_throughPut_inner(func/nano) = 0.002271193301029053
inquiry average exec time = 1622.2486506569876
buyTicket average exec time = 2220.5906356787436
refundTicket average exec time = 580.6051463753486
====================================================================

====================================================================
ImplSix class repeat multi thread test finished.
repeat test count: 5
minFullElapsedTimePerEpoch = 185480670, maxFullElapsedTimePerEpoch = 494781435
avgFullElapsedTimePerEpoch = 259960137, midFullElapsedTimePerEpoch = 186042989
minFullElapsedTimeInnerPerEpoch = 184940764, maxFullElapsedTimeInnerPerEpoch = 494332647
avgFullElapsedTimeInnerPerEpoch = 259470657, midFullElapsedTimeInnerPerEpoch = 185470330
fullFuncCallCount = 2000000, avgFuncCallCount = 500000
best_throughPut(func/nano) = 0.0021565589557122045
mid_throughput(func/nano) = 0.002150040709139542
avg_throughPut(func/nano) = 0.001538697450371016
best_throughPut_inner(func/nano) = 0.0021565589557122045
avg_throughPut_inner(func/nano) = 0.001541600135540567
inquiry average exec time = 1949.3409016542187
buyTicket average exec time = 5285.50952815449
refundTicket average exec time = 509.51396288215057
====================================================================

====================================================================
ImplSeven class repeat multi thread test finished.
repeat test count: 5
minFullElapsedTimePerEpoch = 173963909, maxFullElapsedTimePerEpoch = 219405473
avgFullElapsedTimePerEpoch = 192309961, midFullElapsedTimePerEpoch = 190561204
minFullElapsedTimeInnerPerEpoch = 173457708, maxFullElapsedTimeInnerPerEpoch = 218926805
avgFullElapsedTimeInnerPerEpoch = 191530388, midFullElapsedTimeInnerPerEpoch = 189184100
fullFuncCallCount = 2000000, avgFuncCallCount = 500000
best_throughPut(func/nano) = 0.002299327500165566
mid_throughput(func/nano) = 0.0020990631440384894
avg_throughPut(func/nano) = 0.0020799754621134785
best_throughPut_inner(func/nano) = 0.002299327500165566
avg_throughPut_inner(func/nano) = 0.0020884414435582933
inquiry average exec time = 1889.4735286388034
buyTicket average exec time = 2026.6843919288492
refundTicket average exec time = 421.28541759680553
====================================================================

====================================================================
ImplEight class repeat multi thread test finished.
repeat test count: 5
minFullElapsedTimePerEpoch = 169195828, maxFullElapsedTimePerEpoch = 218430873
avgFullElapsedTimePerEpoch = 185468282, midFullElapsedTimePerEpoch = 179280870
minFullElapsedTimeInnerPerEpoch = 168102806, maxFullElapsedTimeInnerPerEpoch = 217205019
avgFullElapsedTimeInnerPerEpoch = 184304504, midFullElapsedTimeInnerPerEpoch = 178148469
fullFuncCallCount = 2000000, avgFuncCallCount = 500000
best_throughPut(func/nano) = 0.0023641244865683095
mid_throughput(func/nano) = 0.002231135982327618
avg_throughPut(func/nano) = 0.0021567029989526727
best_throughPut_inner(func/nano) = 0.0023641244865683095
avg_throughPut_inner(func/nano) = 0.002170321350366999
inquiry average exec time = 1833.0603752428294
buyTicket average exec time = 2009.8874048757575
refundTicket average exec time = 533.7333570505176
====================================================================

====================================================================
ImplNine class repeat multi thread test finished.
repeat test count: 5
minFullElapsedTimePerEpoch = 84966734, maxFullElapsedTimePerEpoch = 135107805
avgFullElapsedTimePerEpoch = 105011564, midFullElapsedTimePerEpoch = 97059243
minFullElapsedTimeInnerPerEpoch = 83487308, maxFullElapsedTimeInnerPerEpoch = 133831446
avgFullElapsedTimeInnerPerEpoch = 103719299, midFullElapsedTimeInnerPerEpoch = 95856919
fullFuncCallCount = 2000000, avgFuncCallCount = 500000
best_throughPut(func/nano) = 0.004707724790269095
mid_throughput(func/nano) = 0.004121194310159621
avg_throughPut(func/nano) = 0.0038091043001702175
best_throughPut_inner(func/nano) = 0.004707724790269095
avg_throughPut_inner(func/nano) = 0.0038565628948186393
inquiry average exec time = 82.4529541278116
buyTicket average exec time = 1670.0550363525635
refundTicket average exec time = 1969.327687706281
====================================================================

====================================================================
ImplTen class repeat multi thread test finished.
repeat test count: 5
minFullElapsedTimePerEpoch = 152794518, maxFullElapsedTimePerEpoch = 382225749
avgFullElapsedTimePerEpoch = 221246767, midFullElapsedTimePerEpoch = 199794946
minFullElapsedTimeInnerPerEpoch = 151624976, maxFullElapsedTimeInnerPerEpoch = 380136013
avgFullElapsedTimeInnerPerEpoch = 209838684, midFullElapsedTimeInnerPerEpoch = 165285673
fullFuncCallCount = 2000000, avgFuncCallCount = 500000
best_throughPut(func/nano) = 0.0026178949692422866
mid_throughput(func/nano) = 0.002002052644514842
avg_throughPut(func/nano) = 0.001807936022857229
best_throughPut_inner(func/nano) = 0.0026178949692422866
avg_throughPut_inner(func/nano) = 0.0019062262132753369
inquiry average exec time = 920.7948894420538
buyTicket average exec time = 6111.398453958206
refundTicket average exec time = 1048.0125060581684
====================================================================

====================================================================
ImplEleven class repeat multi thread test finished.
repeat test count: 5
minFullElapsedTimePerEpoch = 139435702, maxFullElapsedTimePerEpoch = 195024351
avgFullElapsedTimePerEpoch = 166996486, midFullElapsedTimePerEpoch = 156866931
minFullElapsedTimeInnerPerEpoch = 139056634, maxFullElapsedTimeInnerPerEpoch = 194478941
avgFullElapsedTimeInnerPerEpoch = 166330894, midFullElapsedTimeInnerPerEpoch = 156206584
fullFuncCallCount = 2000000, avgFuncCallCount = 500000
best_throughPut(func/nano) = 0.002868705749406992
mid_throughput(func/nano) = 0.0025499319547470463
avg_throughPut(func/nano) = 0.002395259981698058
best_throughPut_inner(func/nano) = 0.002868705749406992
avg_throughPut_inner(func/nano) = 0.002404844887083935
inquiry average exec time = 1185.971334217965
buyTicket average exec time = 2957.8329402161394
refundTicket average exec time = 339.59200087814713
====================================================================

====================================================================
ImplTwelve class repeat multi thread test finished.
repeat test count: 5
minFullElapsedTimePerEpoch = 155281888, maxFullElapsedTimePerEpoch = 226968956
avgFullElapsedTimePerEpoch = 171727892, midFullElapsedTimePerEpoch = 159377165
minFullElapsedTimeInnerPerEpoch = 154822544, maxFullElapsedTimeInnerPerEpoch = 226431928
avgFullElapsedTimeInnerPerEpoch = 171257700, midFullElapsedTimeInnerPerEpoch = 158906016
fullFuncCallCount = 2000000, avgFuncCallCount = 500000
best_throughPut(func/nano) = 0.002575960436544924
mid_throughput(func/nano) = 0.0025097698280679044
avg_throughPut(func/nano) = 0.002329266348881753
best_throughPut_inner(func/nano) = 0.002575960436544924
avg_throughPut_inner(func/nano) = 0.0023356614038376085
inquiry average exec time = 1479.1494931937862
buyTicket average exec time = 2695.095688617058
refundTicket average exec time = 329.9399143988693
====================================================================

====================================================================
ImplThirteen class repeat multi thread test finished.
repeat test count: 5
minFullElapsedTimePerEpoch = 73570320, maxFullElapsedTimePerEpoch = 116174952
avgFullElapsedTimePerEpoch = 83469796, midFullElapsedTimePerEpoch = 75476443
minFullElapsedTimeInnerPerEpoch = 72997993, maxFullElapsedTimeInnerPerEpoch = 115625275
avgFullElapsedTimeInnerPerEpoch = 82916345, midFullElapsedTimeInnerPerEpoch = 75040935
fullFuncCallCount = 2000000, avgFuncCallCount = 500000
best_throughPut(func/nano) = 0.005436975128013579
mid_throughput(func/nano) = 0.005299666811272492
avg_throughPut(func/nano) = 0.004792152600924052
best_throughPut_inner(func/nano) = 0.005436975128013579
avg_throughPut_inner(func/nano) = 0.004824139317766599
inquiry average exec time = 334.28063033693087
buyTicket average exec time = 1956.9930370964569
refundTicket average exec time = 638.2459630810185
====================================================================

====================================================================
ImplFourteen class repeat multi thread test finished.
repeat test count: 5
minFullElapsedTimePerEpoch = 74081304, maxFullElapsedTimePerEpoch = 113491300
avgFullElapsedTimePerEpoch = 88756500, midFullElapsedTimePerEpoch = 80460890
minFullElapsedTimeInnerPerEpoch = 73679511, maxFullElapsedTimeInnerPerEpoch = 113107818
avgFullElapsedTimeInnerPerEpoch = 88349918, midFullElapsedTimeInnerPerEpoch = 80035675
fullFuncCallCount = 2000000, avgFuncCallCount = 500000
best_throughPut(func/nano) = 0.0053994729898383
mid_throughput(func/nano) = 0.004971359377207983
avg_throughPut(func/nano) = 0.00450671218445973
best_throughPut_inner(func/nano) = 0.0053994729898383
avg_throughPut_inner(func/nano) = 0.004527451853435789
inquiry average exec time = 293.5533922443794
buyTicket average exec time = 2304.836369493396
refundTicket average exec time = 662.3395436445484
====================================================================

====================================================================
ImplFifteen class repeat multi thread test finished.
repeat test count: 5
minFullElapsedTimePerEpoch = 96344517, maxFullElapsedTimePerEpoch = 655751369
avgFullElapsedTimePerEpoch = 210132452, midFullElapsedTimePerEpoch = 98657241
minFullElapsedTimeInnerPerEpoch = 96032696, maxFullElapsedTimeInnerPerEpoch = 655285439
avgFullElapsedTimeInnerPerEpoch = 209756671, midFullElapsedTimeInnerPerEpoch = 98281199
fullFuncCallCount = 2000000, avgFuncCallCount = 500000
best_throughPut(func/nano) = 0.004151767142078257
mid_throughput(func/nano) = 0.004054441376482442
avg_throughPut(func/nano) = 0.001903561283337616
best_throughPut_inner(func/nano) = 0.004151767142078257
avg_throughPut_inner(func/nano) = 0.0019069715308363184
inquiry average exec time = 1491.917314339688
buyTicket average exec time = 4354.652599591496
refundTicket average exec time = 459.7623569198751
====================================================================

====================================================================
ImplSixteen class repeat multi thread test finished.
repeat test count: 5
minFullElapsedTimePerEpoch = 103883422, maxFullElapsedTimePerEpoch = 479355849
avgFullElapsedTimePerEpoch = 179964663, midFullElapsedTimePerEpoch = 105504228
minFullElapsedTimeInnerPerEpoch = 103591243, maxFullElapsedTimeInnerPerEpoch = 478938940
avgFullElapsedTimeInnerPerEpoch = 179598006, midFullElapsedTimeInnerPerEpoch = 105131147
fullFuncCallCount = 2000000, avgFuncCallCount = 500000
best_throughPut(func/nano) = 0.0038504700008823354
mid_throughput(func/nano) = 0.0037913172541293796
avg_throughPut(func/nano) = 0.002222658567143262
best_throughPut_inner(func/nano) = 0.0038504700008823354
avg_throughPut_inner(func/nano) = 0.0022271962195393193
inquiry average exec time = 1743.1085332276277
buyTicket average exec time = 2099.606338817456
refundTicket average exec time = 334.7092244848801
====================================================================

--------------- END TEST THREAD NUM = 4 ---------------


-------------- START TEST THREAD NUM = 8 --------------
Thread Num = 8
====================================================================
ImplOne class repeat multi thread test finished.
repeat test count: 5
minFullElapsedTimePerEpoch = 78696582, maxFullElapsedTimePerEpoch = 91694291
avgFullElapsedTimePerEpoch = 86982564, midFullElapsedTimePerEpoch = 86771708
minFullElapsedTimeInnerPerEpoch = 78410636, maxFullElapsedTimeInnerPerEpoch = 91344878
avgFullElapsedTimeInnerPerEpoch = 86640056, midFullElapsedTimeInnerPerEpoch = 86401553
fullFuncCallCount = 4000000, avgFuncCallCount = 500000
best_throughPut(func/nano) = 0.010165625744711505
mid_throughput(func/nano) = 0.009219594939862196
avg_throughPut(func/nano) = 0.009197245553718099
best_throughPut_inner(func/nano) = 0.010165625744711505
avg_throughPut_inner(func/nano) = 0.009233604373478244
inquiry average exec time = 529.4033729407817
buyTicket average exec time = 1403.8825065633375
refundTicket average exec time = 1006.4145392493175
====================================================================

====================================================================
ImplTwo class repeat multi thread test finished.
repeat test count: 5
minFullElapsedTimePerEpoch = 115553874, maxFullElapsedTimePerEpoch = 138621482
avgFullElapsedTimePerEpoch = 124631178, midFullElapsedTimePerEpoch = 123532817
minFullElapsedTimeInnerPerEpoch = 115217609, maxFullElapsedTimeInnerPerEpoch = 138403673
avgFullElapsedTimeInnerPerEpoch = 124331805, midFullElapsedTimeInnerPerEpoch = 123262867
fullFuncCallCount = 4000000, avgFuncCallCount = 500000
best_throughPut(func/nano) = 0.006923177668625805
mid_throughput(func/nano) = 0.006476011957211337
avg_throughPut(func/nano) = 0.0064189395690378535
best_throughPut_inner(func/nano) = 0.006923177668625805
avg_throughPut_inner(func/nano) = 0.006434395446925266
inquiry average exec time = 388.9809334226306
buyTicket average exec time = 2762.251706888393
refundTicket average exec time = 2808.7595401528824
====================================================================

====================================================================
ImplThree class repeat multi thread test finished.
repeat test count: 5
minFullElapsedTimePerEpoch = 163929940, maxFullElapsedTimePerEpoch = 179150319
avgFullElapsedTimePerEpoch = 171602730, midFullElapsedTimePerEpoch = 173378710
minFullElapsedTimeInnerPerEpoch = 163591631, maxFullElapsedTimeInnerPerEpoch = 178796532
avgFullElapsedTimeInnerPerEpoch = 171243742, midFullElapsedTimeInnerPerEpoch = 172994303
fullFuncCallCount = 4000000, avgFuncCallCount = 500000
best_throughPut(func/nano) = 0.004880133549734722
mid_throughput(func/nano) = 0.004614176677171032
avg_throughPut(func/nano) = 0.004661930494928607
best_throughPut_inner(func/nano) = 0.004880133549734722
avg_throughPut_inner(func/nano) = 0.004671703565085608
inquiry average exec time = 1487.3991694801823
buyTicket average exec time = 2496.5528814178056
refundTicket average exec time = 424.29642048096974
====================================================================

====================================================================
ImplFour class repeat multi thread test finished.
repeat test count: 5
minFullElapsedTimePerEpoch = 172683761, maxFullElapsedTimePerEpoch = 177033638
avgFullElapsedTimePerEpoch = 175345809, midFullElapsedTimePerEpoch = 176027704
minFullElapsedTimeInnerPerEpoch = 172243752, maxFullElapsedTimeInnerPerEpoch = 176672156
avgFullElapsedTimeInnerPerEpoch = 174930696, midFullElapsedTimeInnerPerEpoch = 175614902
fullFuncCallCount = 4000000, avgFuncCallCount = 500000
best_throughPut(func/nano) = 0.004632745982408849
mid_throughput(func/nano) = 0.004544739162194606
avg_throughPut(func/nano) = 0.004562413008685026
best_throughPut_inner(func/nano) = 0.004632745982408849
avg_throughPut_inner(func/nano) = 0.004573239678872598
inquiry average exec time = 1476.9875256750843
buyTicket average exec time = 2648.7048776430834
refundTicket average exec time = 416.73483119037536
====================================================================

====================================================================
ImplSix class repeat multi thread test finished.
repeat test count: 5
minFullElapsedTimePerEpoch = 209845286, maxFullElapsedTimePerEpoch = 217667204
avgFullElapsedTimePerEpoch = 213117273, midFullElapsedTimePerEpoch = 213680333
minFullElapsedTimeInnerPerEpoch = 209434876, maxFullElapsedTimeInnerPerEpoch = 217222952
avgFullElapsedTimeInnerPerEpoch = 212737679, midFullElapsedTimeInnerPerEpoch = 213259183
fullFuncCallCount = 4000000, avgFuncCallCount = 500000
best_throughPut(func/nano) = 0.0038123324819410048
mid_throughput(func/nano) = 0.00374391030174967
avg_throughPut(func/nano) = 0.003753801785930322
best_throughPut_inner(func/nano) = 0.0038123324819410048
avg_throughPut_inner(func/nano) = 0.0037604998031401855
inquiry average exec time = 1793.2476871931658
buyTicket average exec time = 3379.1051106582518
refundTicket average exec time = 484.68993501617086
====================================================================

====================================================================
ImplSeven class repeat multi thread test finished.
repeat test count: 5
minFullElapsedTimePerEpoch = 186389255, maxFullElapsedTimePerEpoch = 218509625
avgFullElapsedTimePerEpoch = 199075526, midFullElapsedTimePerEpoch = 190960555
minFullElapsedTimeInnerPerEpoch = 186017218, maxFullElapsedTimeInnerPerEpoch = 218069712
avgFullElapsedTimeInnerPerEpoch = 198692369, midFullElapsedTimeInnerPerEpoch = 190645037
fullFuncCallCount = 4000000, avgFuncCallCount = 500000
best_throughPut(func/nano) = 0.0042920929106133295
mid_throughput(func/nano) = 0.004189346852285804
avg_throughPut(func/nano) = 0.004018575342104082
best_throughPut_inner(func/nano) = 0.0042920929106133295
avg_throughPut_inner(func/nano) = 0.004026324735199065
inquiry average exec time = 1817.451293983509
buyTicket average exec time = 2186.431979526788
refundTicket average exec time = 417.3800541308546
====================================================================

====================================================================
ImplEight class repeat multi thread test finished.
repeat test count: 5
minFullElapsedTimePerEpoch = 185971597, maxFullElapsedTimePerEpoch = 192141631
avgFullElapsedTimePerEpoch = 187799166, midFullElapsedTimePerEpoch = 186804789
minFullElapsedTimeInnerPerEpoch = 185596078, maxFullElapsedTimeInnerPerEpoch = 191701057
avgFullElapsedTimeInnerPerEpoch = 187392502, midFullElapsedTimeInnerPerEpoch = 186373770
fullFuncCallCount = 4000000, avgFuncCallCount = 500000
best_throughPut(func/nano) = 0.004301732161820388
mid_throughput(func/nano) = 0.004282545454442284
avg_throughPut(func/nano) = 0.004259869822851077
best_throughPut_inner(func/nano) = 0.004301732161820388
avg_throughPut_inner(func/nano) = 0.0042691142466308495
inquiry average exec time = 1796.3623974414943
buyTicket average exec time = 2128.164268962468
refundTicket average exec time = 429.5760784803799
====================================================================

====================================================================
ImplNine class repeat multi thread test finished.
repeat test count: 5
minFullElapsedTimePerEpoch = 174556634, maxFullElapsedTimePerEpoch = 192700669
avgFullElapsedTimePerEpoch = 183599510, midFullElapsedTimePerEpoch = 184558089
minFullElapsedTimeInnerPerEpoch = 174178994, maxFullElapsedTimeInnerPerEpoch = 192333471
avgFullElapsedTimeInnerPerEpoch = 183211390, midFullElapsedTimeInnerPerEpoch = 184150495
fullFuncCallCount = 4000000, avgFuncCallCount = 500000
best_throughPut(func/nano) = 0.004583039794408501
mid_throughput(func/nano) = 0.004334678606257134
avg_throughPut(func/nano) = 0.004357310103932195
best_throughPut_inner(func/nano) = 0.004583039794408501
avg_throughPut_inner(func/nano) = 0.004366540748367228
inquiry average exec time = 76.05695034929339
buyTicket average exec time = 1619.5200940326583
refundTicket average exec time = 5980.6354951722205
====================================================================

====================================================================
ImplTen class repeat multi thread test finished.
repeat test count: 5
minFullElapsedTimePerEpoch = 209811849, maxFullElapsedTimePerEpoch = 228981660
avgFullElapsedTimePerEpoch = 220001655, midFullElapsedTimePerEpoch = 220981185
minFullElapsedTimeInnerPerEpoch = 209511384, maxFullElapsedTimeInnerPerEpoch = 228687898
avgFullElapsedTimeInnerPerEpoch = 219722471, midFullElapsedTimeInnerPerEpoch = 220774916
fullFuncCallCount = 4000000, avgFuncCallCount = 500000
best_throughPut(func/nano) = 0.0038129400403882816
mid_throughput(func/nano) = 0.003620217712200249
avg_throughPut(func/nano) = 0.003636336281197521
best_throughPut_inner(func/nano) = 0.0038129400403882816
avg_throughPut_inner(func/nano) = 0.0036409566866740725
inquiry average exec time = 1088.2104078951174
buyTicket average exec time = 4450.813150544554
refundTicket average exec time = 1435.020057729442
====================================================================

====================================================================
ImplEleven class repeat multi thread test finished.
repeat test count: 5
minFullElapsedTimePerEpoch = 174779816, maxFullElapsedTimePerEpoch = 208292734
avgFullElapsedTimePerEpoch = 182523066, midFullElapsedTimePerEpoch = 176179220
minFullElapsedTimeInnerPerEpoch = 174413023, maxFullElapsedTimeInnerPerEpoch = 207882798
avgFullElapsedTimeInnerPerEpoch = 182142589, midFullElapsedTimeInnerPerEpoch = 175794725
fullFuncCallCount = 4000000, avgFuncCallCount = 500000
best_throughPut(func/nano) = 0.004577187562664558
mid_throughput(func/nano) = 0.004540830638255749
avg_throughPut(func/nano) = 0.0043830076796978635
best_throughPut_inner(func/nano) = 0.004577187562664558
avg_throughPut_inner(func/nano) = 0.004392163328698484
inquiry average exec time = 1442.1673968876935
buyTicket average exec time = 2975.4170947164644
refundTicket average exec time = 373.724833961452
====================================================================

====================================================================
ImplTwelve class repeat multi thread test finished.
repeat test count: 5
minFullElapsedTimePerEpoch = 184886830, maxFullElapsedTimePerEpoch = 195203279
avgFullElapsedTimePerEpoch = 189891186, midFullElapsedTimePerEpoch = 189627961
minFullElapsedTimeInnerPerEpoch = 184495764, maxFullElapsedTimeInnerPerEpoch = 194806267
avgFullElapsedTimeInnerPerEpoch = 189485247, midFullElapsedTimeInnerPerEpoch = 189246542
fullFuncCallCount = 4000000, avgFuncCallCount = 500000
best_throughPut(func/nano) = 0.004326971261284538
mid_throughput(func/nano) = 0.004218787122854736
avg_throughPut(func/nano) = 0.004212939088178637
best_throughPut_inner(func/nano) = 0.004326971261284538
avg_throughPut_inner(func/nano) = 0.004221964573315832
inquiry average exec time = 1772.5562300911695
buyTicket average exec time = 2393.1167642953974
refundTicket average exec time = 391.1237347691555
====================================================================

====================================================================
ImplThirteen class repeat multi thread test finished.
repeat test count: 5
minFullElapsedTimePerEpoch = 91951631, maxFullElapsedTimePerEpoch = 104621601
avgFullElapsedTimePerEpoch = 96905783, midFullElapsedTimePerEpoch = 94315684
minFullElapsedTimeInnerPerEpoch = 91578873, maxFullElapsedTimeInnerPerEpoch = 104341909
avgFullElapsedTimeInnerPerEpoch = 96578151, midFullElapsedTimeInnerPerEpoch = 93939476
fullFuncCallCount = 4000000, avgFuncCallCount = 500000
best_throughPut(func/nano) = 0.008700226317899679
mid_throughput(func/nano) = 0.008482152342764115
avg_throughPut(func/nano) = 0.008255441267111994
best_throughPut_inner(func/nano) = 0.008700226317899679
avg_throughPut_inner(func/nano) = 0.008283447050047583
inquiry average exec time = 550.5315625357184
buyTicket average exec time = 1961.3254423380135
refundTicket average exec time = 635.4266767354982
====================================================================

====================================================================
ImplFourteen class repeat multi thread test finished.
repeat test count: 5
minFullElapsedTimePerEpoch = 100668084, maxFullElapsedTimePerEpoch = 116040068
avgFullElapsedTimePerEpoch = 105494869, midFullElapsedTimePerEpoch = 103765103
minFullElapsedTimeInnerPerEpoch = 100276862, maxFullElapsedTimeInnerPerEpoch = 115750742
avgFullElapsedTimeInnerPerEpoch = 105145640, midFullElapsedTimeInnerPerEpoch = 103466162
fullFuncCallCount = 4000000, avgFuncCallCount = 500000
best_throughPut(func/nano) = 0.007946907979295603
mid_throughput(func/nano) = 0.007709721061039182
avg_throughPut(func/nano) = 0.007583307203310523
best_throughPut_inner(func/nano) = 0.007946907979295603
avg_throughPut_inner(func/nano) = 0.007608494275178695
inquiry average exec time = 541.7959273042635
buyTicket average exec time = 2402.901623091628
refundTicket average exec time = 634.9142375053824
====================================================================

====================================================================
ImplFifteen class repeat multi thread test finished.
repeat test count: 5
minFullElapsedTimePerEpoch = 116871847, maxFullElapsedTimePerEpoch = 160169696
avgFullElapsedTimePerEpoch = 128628042, midFullElapsedTimePerEpoch = 122528799
minFullElapsedTimeInnerPerEpoch = 116444531, maxFullElapsedTimeInnerPerEpoch = 159707306
avgFullElapsedTimeInnerPerEpoch = 128217664, midFullElapsedTimeInnerPerEpoch = 122232164
fullFuncCallCount = 4000000, avgFuncCallCount = 500000
best_throughPut(func/nano) = 0.006845104450176097
mid_throughput(func/nano) = 0.006529077298798954
avg_throughPut(func/nano) = 0.006219483617732438
best_throughPut_inner(func/nano) = 0.006845104450176097
avg_throughPut_inner(func/nano) = 0.006239389917445384
inquiry average exec time = 484.5549572455759
buyTicket average exec time = 3626.1568072219147
refundTicket average exec time = 373.25971903052516
====================================================================

====================================================================
ImplSixteen class repeat multi thread test finished.
repeat test count: 5
minFullElapsedTimePerEpoch = 123500327, maxFullElapsedTimePerEpoch = 132396980
avgFullElapsedTimePerEpoch = 126983614, midFullElapsedTimePerEpoch = 125747579
minFullElapsedTimeInnerPerEpoch = 123217799, maxFullElapsedTimeInnerPerEpoch = 132094803
avgFullElapsedTimeInnerPerEpoch = 126630665, midFullElapsedTimeInnerPerEpoch = 125410922
fullFuncCallCount = 4000000, avgFuncCallCount = 500000
best_throughPut(func/nano) = 0.006477715641999879
mid_throughput(func/nano) = 0.006361951509221502
avg_throughPut(func/nano) = 0.006300025450527814
best_throughPut_inner(func/nano) = 0.006477715641999879
avg_throughPut_inner(func/nano) = 0.006317585080991243
inquiry average exec time = 906.7517358445563
buyTicket average exec time = 2388.424157475548
refundTicket average exec time = 373.71003143026456
====================================================================

--------------- END TEST THREAD NUM = 8 ---------------


-------------- START TEST THREAD NUM = 16 --------------
Thread Num = 16
====================================================================
ImplOne class repeat multi thread test finished.
repeat test count: 5
minFullElapsedTimePerEpoch = 134827064, maxFullElapsedTimePerEpoch = 148531548
avgFullElapsedTimePerEpoch = 142484015, midFullElapsedTimePerEpoch = 143307819
minFullElapsedTimeInnerPerEpoch = 134344100, maxFullElapsedTimeInnerPerEpoch = 148199230
avgFullElapsedTimeInnerPerEpoch = 142087355, midFullElapsedTimeInnerPerEpoch = 142946893
fullFuncCallCount = 8000000, avgFuncCallCount = 500000
best_throughPut(func/nano) = 0.011867053635462982
mid_throughput(func/nano) = 0.0111647781060711
avg_throughPut(func/nano) = 0.01122932983043747
best_throughPut_inner(func/nano) = 0.011867053635462982
avg_throughPut_inner(func/nano) = 0.011260678334113546
inquiry average exec time = 762.1175637285019
buyTicket average exec time = 2622.0102923912236
refundTicket average exec time = 2379.5840424947155
====================================================================

====================================================================
ImplTwo class repeat multi thread test finished.
repeat test count: 5
minFullElapsedTimePerEpoch = 167306129, maxFullElapsedTimePerEpoch = 227825614
avgFullElapsedTimePerEpoch = 199298122, midFullElapsedTimePerEpoch = 188460852
minFullElapsedTimeInnerPerEpoch = 166968704, maxFullElapsedTimeInnerPerEpoch = 227460397
avgFullElapsedTimeInnerPerEpoch = 198944795, midFullElapsedTimeInnerPerEpoch = 188112799
fullFuncCallCount = 8000000, avgFuncCallCount = 500000
best_throughPut(func/nano) = 0.009563307749472824
mid_throughput(func/nano) = 0.008489826842128465
avg_throughPut(func/nano) = 0.008028173993531158
best_throughPut_inner(func/nano) = 0.009563307749472824
avg_throughPut_inner(func/nano) = 0.008042432072676242
inquiry average exec time = 591.4512453388303
buyTicket average exec time = 4588.716218953749
refundTicket average exec time = 4613.192224659785
====================================================================

====================================================================
ImplThree class repeat multi thread test finished.
repeat test count: 5
minFullElapsedTimePerEpoch = 191370922, maxFullElapsedTimePerEpoch = 251424767
avgFullElapsedTimePerEpoch = 216031400, midFullElapsedTimePerEpoch = 207843307
minFullElapsedTimeInnerPerEpoch = 190234052, maxFullElapsedTimeInnerPerEpoch = 250419332
avgFullElapsedTimeInnerPerEpoch = 215082896, midFullElapsedTimeInnerPerEpoch = 207342933
fullFuncCallCount = 8000000, avgFuncCallCount = 500000
best_throughPut(func/nano) = 0.008360726819302255
mid_throughput(func/nano) = 0.007698106920517773
avg_throughPut(func/nano) = 0.0074063307463637235
best_throughPut_inner(func/nano) = 0.008360726819302255
avg_throughPut_inner(func/nano) = 0.0074389922664980295
inquiry average exec time = 1515.3384292815338
buyTicket average exec time = 3799.25857754299
refundTicket average exec time = 416.86541478286193
====================================================================

====================================================================
ImplFour class repeat multi thread test finished.
repeat test count: 5
minFullElapsedTimePerEpoch = 189361480, maxFullElapsedTimePerEpoch = 226410284
avgFullElapsedTimePerEpoch = 208566305, midFullElapsedTimePerEpoch = 214940510
minFullElapsedTimeInnerPerEpoch = 188240472, maxFullElapsedTimeInnerPerEpoch = 225225965
avgFullElapsedTimeInnerPerEpoch = 207431513, midFullElapsedTimeInnerPerEpoch = 213789560
fullFuncCallCount = 8000000, avgFuncCallCount = 500000
best_throughPut(func/nano) = 0.008449448113734642
mid_throughput(func/nano) = 0.007443920180518786
avg_throughPut(func/nano) = 0.0076714213257026345
best_throughPut_inner(func/nano) = 0.008449448113734642
avg_throughPut_inner(func/nano) = 0.007713389238018044
inquiry average exec time = 1505.539204230235
buyTicket average exec time = 3389.7388578364826
refundTicket average exec time = 415.5224346766207
====================================================================

====================================================================
ImplSix class repeat multi thread test finished.
repeat test count: 5
minFullElapsedTimePerEpoch = 226528494, maxFullElapsedTimePerEpoch = 259135344
avgFullElapsedTimePerEpoch = 236120796, midFullElapsedTimePerEpoch = 229762037
minFullElapsedTimeInnerPerEpoch = 226066572, maxFullElapsedTimeInnerPerEpoch = 258720831
avgFullElapsedTimeInnerPerEpoch = 235562788, midFullElapsedTimeInnerPerEpoch = 228731874
fullFuncCallCount = 8000000, avgFuncCallCount = 500000
best_throughPut(func/nano) = 0.007063129109047094
mid_throughput(func/nano) = 0.0069637265620168575
avg_throughPut(func/nano) = 0.00677619263997399
best_throughPut_inner(func/nano) = 0.007063129109047094
avg_throughPut_inner(func/nano) = 0.006792244282658091
inquiry average exec time = 1839.1009121829666
buyTicket average exec time = 4006.36569955753
refundTicket average exec time = 526.17560679946
====================================================================

====================================================================
ImplSeven class repeat multi thread test finished.
repeat test count: 5
minFullElapsedTimePerEpoch = 197604338, maxFullElapsedTimePerEpoch = 201238912
avgFullElapsedTimePerEpoch = 199174075, midFullElapsedTimePerEpoch = 199182877
minFullElapsedTimeInnerPerEpoch = 197264376, maxFullElapsedTimeInnerPerEpoch = 200763633
avgFullElapsedTimeInnerPerEpoch = 198773042, midFullElapsedTimeInnerPerEpoch = 198829644
fullFuncCallCount = 8000000, avgFuncCallCount = 500000
best_throughPut(func/nano) = 0.008096988235146943
mid_throughput(func/nano) = 0.008032819005822473
avg_throughPut(func/nano) = 0.008033173996163908
best_throughPut_inner(func/nano) = 0.008096988235146943
avg_throughPut_inner(func/nano) = 0.008049381263682627
inquiry average exec time = 1851.017941866951
buyTicket average exec time = 2542.618926542897
refundTicket average exec time = 450.32728031517513
====================================================================

====================================================================
ImplEight class repeat multi thread test finished.
repeat test count: 5
minFullElapsedTimePerEpoch = 195558839, maxFullElapsedTimePerEpoch = 232735157
avgFullElapsedTimePerEpoch = 210251032, midFullElapsedTimePerEpoch = 201822515
minFullElapsedTimeInnerPerEpoch = 195082295, maxFullElapsedTimeInnerPerEpoch = 232253905
avgFullElapsedTimeInnerPerEpoch = 209784590, midFullElapsedTimeInnerPerEpoch = 201415621
fullFuncCallCount = 8000000, avgFuncCallCount = 500000
best_throughPut(func/nano) = 0.008181680808608196
mid_throughput(func/nano) = 0.007927757713256125
avg_throughPut(func/nano) = 0.007609950756389153
best_throughPut_inner(func/nano) = 0.008181680808608196
avg_throughPut_inner(func/nano) = 0.007626870972743994
inquiry average exec time = 1866.465856436425
buyTicket average exec time = 2720.5170696808377
refundTicket average exec time = 463.5492528652256
====================================================================

====================================================================
ImplNine class repeat multi thread test finished.
repeat test count: 5
minFullElapsedTimePerEpoch = 357817326, maxFullElapsedTimePerEpoch = 376061874
avgFullElapsedTimePerEpoch = 369362852, midFullElapsedTimePerEpoch = 372501874
minFullElapsedTimeInnerPerEpoch = 357360907, maxFullElapsedTimeInnerPerEpoch = 375615309
avgFullElapsedTimeInnerPerEpoch = 368886826, midFullElapsedTimeInnerPerEpoch = 372060459
fullFuncCallCount = 8000000, avgFuncCallCount = 500000
best_throughPut(func/nano) = 0.004471555410371604
mid_throughput(func/nano) = 0.004295280404414825
avg_throughPut(func/nano) = 0.004331783749601327
best_throughPut_inner(func/nano) = 0.004471555410371604
avg_throughPut_inner(func/nano) = 0.004337373652915434
inquiry average exec time = 78.50015239054856
buyTicket average exec time = 2558.7132314806136
refundTicket average exec time = 14426.244179059824
====================================================================

====================================================================
ImplTen class repeat multi thread test finished.
repeat test count: 5
minFullElapsedTimePerEpoch = 189945454, maxFullElapsedTimePerEpoch = 257007919
avgFullElapsedTimePerEpoch = 232996502, midFullElapsedTimePerEpoch = 246194550
minFullElapsedTimeInnerPerEpoch = 189717614, maxFullElapsedTimeInnerPerEpoch = 256714563
avgFullElapsedTimeInnerPerEpoch = 232620452, midFullElapsedTimeInnerPerEpoch = 245894456
fullFuncCallCount = 8000000, avgFuncCallCount = 500000
best_throughPut(func/nano) = 0.00842347087706558
mid_throughput(func/nano) = 0.006498925341767314
avg_throughPut(func/nano) = 0.0068670558839548585
best_throughPut_inner(func/nano) = 0.00842347087706558
avg_throughPut_inner(func/nano) = 0.0068781570418408435
inquiry average exec time = 1198.9868203486233
buyTicket average exec time = 4553.884848098449
refundTicket average exec time = 1603.119922383735
====================================================================

====================================================================
ImplEleven class repeat multi thread test finished.
repeat test count: 5
minFullElapsedTimePerEpoch = 190589441, maxFullElapsedTimePerEpoch = 210575964
avgFullElapsedTimePerEpoch = 200917983, midFullElapsedTimePerEpoch = 197259593
minFullElapsedTimeInnerPerEpoch = 190227489, maxFullElapsedTimeInnerPerEpoch = 210274808
avgFullElapsedTimeInnerPerEpoch = 200504713, midFullElapsedTimeInnerPerEpoch = 196927764
fullFuncCallCount = 8000000, avgFuncCallCount = 500000
best_throughPut(func/nano) = 0.008395008619601334
mid_throughput(func/nano) = 0.008111139112002527
avg_throughPut(func/nano) = 0.007963448448514437
best_throughPut_inner(func/nano) = 0.008395008619601334
avg_throughPut_inner(func/nano) = 0.007979862298797933
inquiry average exec time = 1511.0948857860906
buyTicket average exec time = 3816.55856557226
refundTicket average exec time = 459.2011588688057
====================================================================

====================================================================
ImplTwelve class repeat multi thread test finished.
repeat test count: 5
minFullElapsedTimePerEpoch = 205675465, maxFullElapsedTimePerEpoch = 212672323
avgFullElapsedTimePerEpoch = 209606251, midFullElapsedTimePerEpoch = 209929774
minFullElapsedTimeInnerPerEpoch = 205234936, maxFullElapsedTimeInnerPerEpoch = 212276637
avgFullElapsedTimeInnerPerEpoch = 209170141, midFullElapsedTimeInnerPerEpoch = 209427502
fullFuncCallCount = 8000000, avgFuncCallCount = 500000
best_throughPut(func/nano) = 0.007779245813301066
mid_throughput(func/nano) = 0.007621596353454847
avg_throughPut(func/nano) = 0.0076333601329475614
best_throughPut_inner(func/nano) = 0.007779245813301066
avg_throughPut_inner(func/nano) = 0.007649275333232194
inquiry average exec time = 1868.7103762341235
buyTicket average exec time = 2913.9044363927383
refundTicket average exec time = 466.8077226930673
====================================================================

====================================================================
ImplThirteen class repeat multi thread test finished.
repeat test count: 5
minFullElapsedTimePerEpoch = 153620315, maxFullElapsedTimePerEpoch = 171164714
avgFullElapsedTimePerEpoch = 164439186, midFullElapsedTimePerEpoch = 166283875
minFullElapsedTimeInnerPerEpoch = 153198958, maxFullElapsedTimeInnerPerEpoch = 170701605
avgFullElapsedTimeInnerPerEpoch = 164060665, midFullElapsedTimeInnerPerEpoch = 166054265
fullFuncCallCount = 8000000, avgFuncCallCount = 500000
best_throughPut(func/nano) = 0.010415289149745592
mid_throughput(func/nano) = 0.009622099557157902
avg_throughPut(func/nano) = 0.009730040867509525
best_throughPut_inner(func/nano) = 0.010415289149745592
avg_throughPut_inner(func/nano) = 0.009752490031659936
inquiry average exec time = 1162.815964822999
buyTicket average exec time = 2657.7458047439964
refundTicket average exec time = 901.0172893913905
====================================================================

====================================================================
ImplFourteen class repeat multi thread test finished.
repeat test count: 5
minFullElapsedTimePerEpoch = 170067482, maxFullElapsedTimePerEpoch = 183070385
avgFullElapsedTimePerEpoch = 175889569, midFullElapsedTimePerEpoch = 174613546
minFullElapsedTimeInnerPerEpoch = 169734184, maxFullElapsedTimeInnerPerEpoch = 182596788
avgFullElapsedTimeInnerPerEpoch = 175462685, midFullElapsedTimeInnerPerEpoch = 174223932
fullFuncCallCount = 8000000, avgFuncCallCount = 500000
best_throughPut(func/nano) = 0.009408030160639411
mid_throughput(func/nano) = 0.009163092077632969
avg_throughPut(func/nano) = 0.009096616752753542
best_throughPut_inner(func/nano) = 0.009408030160639411
avg_throughPut_inner(func/nano) = 0.00911874795487143
inquiry average exec time = 1115.3883134575565
buyTicket average exec time = 3427.7297700073264
refundTicket average exec time = 894.8208163107078
====================================================================

====================================================================
ImplFifteen class repeat multi thread test finished.
repeat test count: 5
minFullElapsedTimePerEpoch = 137227157, maxFullElapsedTimePerEpoch = 169129807
avgFullElapsedTimePerEpoch = 148589377, midFullElapsedTimePerEpoch = 145376351
minFullElapsedTimeInnerPerEpoch = 136779713, maxFullElapsedTimeInnerPerEpoch = 168746835
avgFullElapsedTimeInnerPerEpoch = 148201111, midFullElapsedTimeInnerPerEpoch = 145030892
fullFuncCallCount = 8000000, avgFuncCallCount = 500000
best_throughPut(func/nano) = 0.011659499730071651
mid_throughput(func/nano) = 0.011005916636331036
avg_throughPut(func/nano) = 0.010767929930818675
best_throughPut_inner(func/nano) = 0.011659499730071651
avg_throughPut_inner(func/nano) = 0.010796140387908429
inquiry average exec time = 666.6632862957507
buyTicket average exec time = 4160.158780524302
refundTicket average exec time = 399.5983495826963
====================================================================

====================================================================
ImplSixteen class repeat multi thread test finished.
repeat test count: 5
minFullElapsedTimePerEpoch = 156848956, maxFullElapsedTimePerEpoch = 239233137
avgFullElapsedTimePerEpoch = 185238702, midFullElapsedTimePerEpoch = 168263925
minFullElapsedTimeInnerPerEpoch = 155420644, maxFullElapsedTimeInnerPerEpoch = 238549143
avgFullElapsedTimeInnerPerEpoch = 184564159, midFullElapsedTimeInnerPerEpoch = 167846427
fullFuncCallCount = 8000000, avgFuncCallCount = 500000
best_throughPut(func/nano) = 0.010200896714926175
mid_throughput(func/nano) = 0.00950887125686626
avg_throughPut(func/nano) = 0.008637503840855027
best_throughPut_inner(func/nano) = 0.010200896714926175
avg_throughPut_inner(func/nano) = 0.008669072092160645
inquiry average exec time = 1254.7490041157025
buyTicket average exec time = 2961.3712880192274
refundTicket average exec time = 438.58679574559585
====================================================================

--------------- END TEST THREAD NUM = 16 ---------------


-------------- START TEST THREAD NUM = 32 --------------
Thread Num = 32
====================================================================
ImplOne class repeat multi thread test finished.
repeat test count: 5
minFullElapsedTimePerEpoch = 217501167, maxFullElapsedTimePerEpoch = 250857106
avgFullElapsedTimePerEpoch = 237343005, midFullElapsedTimePerEpoch = 239654443
minFullElapsedTimeInnerPerEpoch = 217201713, maxFullElapsedTimeInnerPerEpoch = 250471779
avgFullElapsedTimeInnerPerEpoch = 236778790, midFullElapsedTimeInnerPerEpoch = 238256856
fullFuncCallCount = 16000000, avgFuncCallCount = 500000
best_throughPut(func/nano) = 0.014712564737641156
mid_throughput(func/nano) = 0.013352558625420518
avg_throughPut(func/nano) = 0.013482596632666717
best_throughPut_inner(func/nano) = 0.014712564737641156
avg_throughPut_inner(func/nano) = 0.013514724017299015
inquiry average exec time = 967.1609851517738
buyTicket average exec time = 4918.788496109383
refundTicket average exec time = 4728.824038973349
====================================================================

====================================================================
ImplTwo class repeat multi thread test finished.
repeat test count: 5
minFullElapsedTimePerEpoch = 352545501, maxFullElapsedTimePerEpoch = 386404092
avgFullElapsedTimePerEpoch = 374177632, midFullElapsedTimePerEpoch = 381273781
minFullElapsedTimeInnerPerEpoch = 352201111, maxFullElapsedTimeInnerPerEpoch = 386044390
avgFullElapsedTimeInnerPerEpoch = 373794338, midFullElapsedTimeInnerPerEpoch = 380846013
fullFuncCallCount = 16000000, avgFuncCallCount = 500000
best_throughPut(func/nano) = 0.009076842537837406
mid_throughput(func/nano) = 0.008392919102926723
avg_throughPut(func/nano) = 0.008552087902464464
best_throughPut_inner(func/nano) = 0.009076842537837406
avg_throughPut_inner(func/nano) = 0.008560857334334475
inquiry average exec time = 832.5925787844286
buyTicket average exec time = 9567.450610376287
refundTicket average exec time = 9898.88937189496
====================================================================

====================================================================
ImplThree class repeat multi thread test finished.
repeat test count: 5
minFullElapsedTimePerEpoch = 211899640, maxFullElapsedTimePerEpoch = 242472463
avgFullElapsedTimePerEpoch = 226816654, midFullElapsedTimePerEpoch = 229535633
minFullElapsedTimeInnerPerEpoch = 211355105, maxFullElapsedTimeInnerPerEpoch = 241964301
avgFullElapsedTimeInnerPerEpoch = 226363657, midFullElapsedTimeInnerPerEpoch = 229135434
fullFuncCallCount = 16000000, avgFuncCallCount = 500000
best_throughPut(func/nano) = 0.015101488610362906
mid_throughput(func/nano) = 0.013941190560160218
avg_throughPut(func/nano) = 0.014108311464642274
best_throughPut_inner(func/nano) = 0.015101488610362906
avg_throughPut_inner(func/nano) = 0.014136544895985667
inquiry average exec time = 1730.2756227203881
buyTicket average exec time = 3603.3287433084056
refundTicket average exec time = 484.73781816545164
====================================================================

====================================================================
ImplFour class repeat multi thread test finished.
repeat test count: 5
minFullElapsedTimePerEpoch = 220915458, maxFullElapsedTimePerEpoch = 262232642
avgFullElapsedTimePerEpoch = 231429952, midFullElapsedTimePerEpoch = 224692379
minFullElapsedTimeInnerPerEpoch = 220587384, maxFullElapsedTimeInnerPerEpoch = 261824722
avgFullElapsedTimeInnerPerEpoch = 231074172, midFullElapsedTimeInnerPerEpoch = 224303857
fullFuncCallCount = 16000000, avgFuncCallCount = 500000
best_throughPut(func/nano) = 0.01448517921276473
mid_throughput(func/nano) = 0.014241693528911366
avg_throughPut(func/nano) = 0.013827078009332172
best_throughPut_inner(func/nano) = 0.01448517921276473
avg_throughPut_inner(func/nano) = 0.013848367267978353
inquiry average exec time = 1683.7713335339001
buyTicket average exec time = 4134.645084768126
refundTicket average exec time = 506.7852342701724
====================================================================

====================================================================
ImplSix class repeat multi thread test finished.
repeat test count: 5
minFullElapsedTimePerEpoch = 257523772, maxFullElapsedTimePerEpoch = 295966355
avgFullElapsedTimePerEpoch = 276052978, midFullElapsedTimePerEpoch = 276239893
minFullElapsedTimeInnerPerEpoch = 257189853, maxFullElapsedTimeInnerPerEpoch = 295521106
avgFullElapsedTimeInnerPerEpoch = 275662371, midFullElapsedTimeInnerPerEpoch = 275767271
fullFuncCallCount = 16000000, avgFuncCallCount = 500000
best_throughPut(func/nano) = 0.012426037313557212
mid_throughput(func/nano) = 0.01158413422930192
avg_throughPut(func/nano) = 0.011591977826806854
best_throughPut_inner(func/nano) = 0.012426037313557212
avg_throughPut_inner(func/nano) = 0.011608403382701806
inquiry average exec time = 2172.398163379971
buyTicket average exec time = 4929.813845449806
refundTicket average exec time = 678.4832270870781
====================================================================

====================================================================
ImplSeven class repeat multi thread test finished.
repeat test count: 5
minFullElapsedTimePerEpoch = 217524954, maxFullElapsedTimePerEpoch = 228854686
avgFullElapsedTimePerEpoch = 221095975, midFullElapsedTimePerEpoch = 219097848
minFullElapsedTimeInnerPerEpoch = 217105231, maxFullElapsedTimeInnerPerEpoch = 228375574
avgFullElapsedTimeInnerPerEpoch = 220647510, midFullElapsedTimeInnerPerEpoch = 218638409
fullFuncCallCount = 16000000, avgFuncCallCount = 500000
best_throughPut(func/nano) = 0.014710955874975153
mid_throughput(func/nano) = 0.014605346557306213
avg_throughPut(func/nano) = 0.014473352579123161
best_throughPut_inner(func/nano) = 0.014710955874975153
avg_throughPut_inner(func/nano) = 0.01450276959844233
inquiry average exec time = 2043.549049074611
buyTicket average exec time = 2855.6219329743135
refundTicket average exec time = 470.34867824662524
====================================================================

====================================================================
ImplEight class repeat multi thread test finished.
repeat test count: 5
minFullElapsedTimePerEpoch = 221499508, maxFullElapsedTimePerEpoch = 230371230
avgFullElapsedTimePerEpoch = 226263343, midFullElapsedTimePerEpoch = 225763201
minFullElapsedTimeInnerPerEpoch = 221123062, maxFullElapsedTimeInnerPerEpoch = 229928430
avgFullElapsedTimeInnerPerEpoch = 225834339, midFullElapsedTimeInnerPerEpoch = 225321090
fullFuncCallCount = 16000000, avgFuncCallCount = 500000
best_throughPut(func/nano) = 0.014446984685853117
mid_throughput(func/nano) = 0.014174143464594125
avg_throughPut(func/nano) = 0.014142812342342171
best_throughPut_inner(func/nano) = 0.014446984685853117
avg_throughPut_inner(func/nano) = 0.014169678597903572
inquiry average exec time = 2091.253443216483
buyTicket average exec time = 2850.277021221439
refundTicket average exec time = 488.4641938415371
====================================================================

====================================================================
ImplNine class repeat multi thread test finished.
repeat test count: 5
minFullElapsedTimePerEpoch = 745708049, maxFullElapsedTimePerEpoch = 804179603
avgFullElapsedTimePerEpoch = 764584708, midFullElapsedTimePerEpoch = 756031435
minFullElapsedTimeInnerPerEpoch = 745322101, maxFullElapsedTimeInnerPerEpoch = 803747411
avgFullElapsedTimeInnerPerEpoch = 764159412, midFullElapsedTimeInnerPerEpoch = 755568808
fullFuncCallCount = 16000000, avgFuncCallCount = 500000
best_throughPut(func/nano) = 0.0042912236287260454
mid_throughput(func/nano) = 0.004232628237210798
avg_throughPut(func/nano) = 0.004185278578707855
best_throughPut_inner(func/nano) = 0.0042912236287260454
avg_throughPut_inner(func/nano) = 0.004187607912365804
inquiry average exec time = 79.96594197133453
buyTicket average exec time = 3276.073290918573
refundTicket average exec time = 34489.725113911016
====================================================================

====================================================================
ImplTen class repeat multi thread test finished.
repeat test count: 5
minFullElapsedTimePerEpoch = 280171421, maxFullElapsedTimePerEpoch = 317650046
avgFullElapsedTimePerEpoch = 292925683, midFullElapsedTimePerEpoch = 289789826
minFullElapsedTimeInnerPerEpoch = 279932920, maxFullElapsedTimeInnerPerEpoch = 317092439
avgFullElapsedTimeInnerPerEpoch = 292534141, midFullElapsedTimeInnerPerEpoch = 289557222
fullFuncCallCount = 16000000, avgFuncCallCount = 500000
best_throughPut(func/nano) = 0.011421578933991273
mid_throughput(func/nano) = 0.011042485666836351
avg_throughPut(func/nano) = 0.010924272556872386
best_throughPut_inner(func/nano) = 0.011421578933991273
avg_throughPut_inner(func/nano) = 0.010938894137488041
inquiry average exec time = 1541.5354905798897
buyTicket average exec time = 5096.977755627902
refundTicket average exec time = 1932.0933217007255
====================================================================

====================================================================
ImplEleven class repeat multi thread test finished.
repeat test count: 5
minFullElapsedTimePerEpoch = 226710330, maxFullElapsedTimePerEpoch = 245385932
avgFullElapsedTimePerEpoch = 232730091, midFullElapsedTimePerEpoch = 230139727
minFullElapsedTimeInnerPerEpoch = 226276832, maxFullElapsedTimeInnerPerEpoch = 244928457
avgFullElapsedTimeInnerPerEpoch = 232327244, midFullElapsedTimeInnerPerEpoch = 229795085
fullFuncCallCount = 16000000, avgFuncCallCount = 500000
best_throughPut(func/nano) = 0.014114928067018384
mid_throughput(func/nano) = 0.01390459631508992
avg_throughPut(func/nano) = 0.013749833492739021
best_throughPut_inner(func/nano) = 0.014114928067018384
avg_throughPut_inner(func/nano) = 0.013773675204445675
inquiry average exec time = 1682.7710290680313
buyTicket average exec time = 4461.833105678784
refundTicket average exec time = 455.0936127697118
====================================================================

====================================================================
ImplTwelve class repeat multi thread test finished.
repeat test count: 5
minFullElapsedTimePerEpoch = 224821563, maxFullElapsedTimePerEpoch = 279582508
avgFullElapsedTimePerEpoch = 237597686, midFullElapsedTimePerEpoch = 227418162
minFullElapsedTimeInnerPerEpoch = 224449212, maxFullElapsedTimeInnerPerEpoch = 279110483
avgFullElapsedTimeInnerPerEpoch = 237184225, midFullElapsedTimeInnerPerEpoch = 226913245
fullFuncCallCount = 16000000, avgFuncCallCount = 500000
best_throughPut(func/nano) = 0.014233510154895596
mid_throughput(func/nano) = 0.014070995789685434
avg_throughPut(func/nano) = 0.013468144635044973
best_throughPut_inner(func/nano) = 0.014233510154895596
avg_throughPut_inner(func/nano) = 0.013491622387618737
inquiry average exec time = 2025.0079509943052
buyTicket average exec time = 3721.542561138461
refundTicket average exec time = 437.7803287703763
====================================================================

====================================================================
ImplThirteen class repeat multi thread test finished.
repeat test count: 5
minFullElapsedTimePerEpoch = 203022869, maxFullElapsedTimePerEpoch = 239214964
avgFullElapsedTimePerEpoch = 221871763, midFullElapsedTimePerEpoch = 223550210
minFullElapsedTimeInnerPerEpoch = 202529198, maxFullElapsedTimeInnerPerEpoch = 238823043
avgFullElapsedTimeInnerPerEpoch = 221435467, midFullElapsedTimeInnerPerEpoch = 223109409
fullFuncCallCount = 16000000, avgFuncCallCount = 500000
best_throughPut(func/nano) = 0.01576177115298277
mid_throughput(func/nano) = 0.014314457588744828
avg_throughPut(func/nano) = 0.01442274562896947
best_throughPut_inner(func/nano) = 0.01576177115298277
avg_throughPut_inner(func/nano) = 0.014451162875367206
inquiry average exec time = 1800.4848290106602
buyTicket average exec time = 3007.9770209294206
refundTicket average exec time = 808.1872960697216
====================================================================

====================================================================
ImplFourteen class repeat multi thread test finished.
repeat test count: 5
minFullElapsedTimePerEpoch = 247775868, maxFullElapsedTimePerEpoch = 259940964
avgFullElapsedTimePerEpoch = 256132136, midFullElapsedTimePerEpoch = 257742463
minFullElapsedTimeInnerPerEpoch = 247409096, maxFullElapsedTimeInnerPerEpoch = 259522644
avgFullElapsedTimeInnerPerEpoch = 255690359, midFullElapsedTimeInnerPerEpoch = 257272938
fullFuncCallCount = 16000000, avgFuncCallCount = 500000
best_throughPut(func/nano) = 0.012914897749445075
mid_throughput(func/nano) = 0.012415493988664181
avg_throughPut(func/nano) = 0.012493551375372905
best_throughPut_inner(func/nano) = 0.012914897749445075
avg_throughPut_inner(func/nano) = 0.01251513749879009
inquiry average exec time = 1891.816492749222
buyTicket average exec time = 4324.782433568463
refundTicket average exec time = 917.2406433871595
====================================================================

====================================================================
ImplFifteen class repeat multi thread test finished.
repeat test count: 5
minFullElapsedTimePerEpoch = 189604198, maxFullElapsedTimePerEpoch = 216630659
avgFullElapsedTimePerEpoch = 203663987, midFullElapsedTimePerEpoch = 205325757
minFullElapsedTimeInnerPerEpoch = 189143588, maxFullElapsedTimeInnerPerEpoch = 216151845
avgFullElapsedTimeInnerPerEpoch = 203218772, midFullElapsedTimeInnerPerEpoch = 204887967
fullFuncCallCount = 16000000, avgFuncCallCount = 500000
best_throughPut(func/nano) = 0.01687726344540114
mid_throughput(func/nano) = 0.015584990635149587
avg_throughPut(func/nano) = 0.015712154353533302
best_throughPut_inner(func/nano) = 0.01687726344540114
avg_throughPut_inner(func/nano) = 0.015746576797541125
inquiry average exec time = 1090.6235362632224
buyTicket average exec time = 5001.416263316792
refundTicket average exec time = 538.3984271837494
====================================================================

====================================================================
ImplSixteen class repeat multi thread test finished.
repeat test count: 5
minFullElapsedTimePerEpoch = 213022356, maxFullElapsedTimePerEpoch = 219091473
avgFullElapsedTimePerEpoch = 215712877, midFullElapsedTimePerEpoch = 214807188
minFullElapsedTimeInnerPerEpoch = 212554321, maxFullElapsedTimeInnerPerEpoch = 218632511
avgFullElapsedTimeInnerPerEpoch = 215270053, midFullElapsedTimeInnerPerEpoch = 214430933
fullFuncCallCount = 16000000, avgFuncCallCount = 500000
best_throughPut(func/nano) = 0.015021897513892862
mid_throughput(func/nano) = 0.014897080632143464
avg_throughPut(func/nano) = 0.014834533962476427
best_throughPut_inner(func/nano) = 0.015021897513892862
avg_throughPut_inner(func/nano) = 0.014865049529206927
inquiry average exec time = 1813.586084347605
buyTicket average exec time = 3343.3858385867634
refundTicket average exec time = 511.96063690406106
====================================================================

--------------- END TEST THREAD NUM = 32 ---------------


-------------- START TEST THREAD NUM = 64 --------------
Thread Num = 64
====================================================================
ImplOne class repeat multi thread test finished.
repeat test count: 5
minFullElapsedTimePerEpoch = 448337146, maxFullElapsedTimePerEpoch = 491087435
avgFullElapsedTimePerEpoch = 463136732, midFullElapsedTimePerEpoch = 463202477
minFullElapsedTimeInnerPerEpoch = 447780362, maxFullElapsedTimeInnerPerEpoch = 490549670
avgFullElapsedTimeInnerPerEpoch = 462581669, midFullElapsedTimeInnerPerEpoch = 462664768
fullFuncCallCount = 32000000, avgFuncCallCount = 500000
best_throughPut(func/nano) = 0.014274971541171385
mid_throughput(func/nano) = 0.01381685184727542
avg_throughPut(func/nano) = 0.013818813231164745
best_throughPut_inner(func/nano) = 0.014274971541171385
avg_throughPut_inner(func/nano) = 0.013835394761395095
inquiry average exec time = 1603.7504008776132
buyTicket average exec time = 10042.290480532072
refundTicket average exec time = 9955.244978387484
====================================================================

====================================================================
ImplTwo class repeat multi thread test finished.
repeat test count: 5
minFullElapsedTimePerEpoch = 681084879, maxFullElapsedTimePerEpoch = 899942986
avgFullElapsedTimePerEpoch = 777773965, midFullElapsedTimePerEpoch = 750497887
minFullElapsedTimeInnerPerEpoch = 680538225, maxFullElapsedTimeInnerPerEpoch = 899394053
avgFullElapsedTimeInnerPerEpoch = 777270775, midFullElapsedTimeInnerPerEpoch = 750005959
fullFuncCallCount = 32000000, avgFuncCallCount = 500000
best_throughPut(func/nano) = 0.009396772997510638
mid_throughput(func/nano) = 0.008527672243799403
avg_throughPut(func/nano) = 0.008228611766401824
best_throughPut_inner(func/nano) = 0.009396772997510638
avg_throughPut_inner(func/nano) = 0.008233938809805373
inquiry average exec time = 1795.5459864555257
buyTicket average exec time = 20483.362918473176
refundTicket average exec time = 20856.17313876569
====================================================================

====================================================================
ImplThree class repeat multi thread test finished.
repeat test count: 5
minFullElapsedTimePerEpoch = 283967953, maxFullElapsedTimePerEpoch = 399254259
avgFullElapsedTimePerEpoch = 323636949, midFullElapsedTimePerEpoch = 308714577
minFullElapsedTimeInnerPerEpoch = 283355341, maxFullElapsedTimeInnerPerEpoch = 398816801
avgFullElapsedTimeInnerPerEpoch = 323124488, midFullElapsedTimeInnerPerEpoch = 308228558
fullFuncCallCount = 32000000, avgFuncCallCount = 500000
best_throughPut(func/nano) = 0.022537754462736856
mid_throughput(func/nano) = 0.02073112342861607
avg_throughPut(func/nano) = 0.019775245131235
best_throughPut_inner(func/nano) = 0.022537754462736856
avg_throughPut_inner(func/nano) = 0.019806607786408314
inquiry average exec time = 2465.039505001403
buyTicket average exec time = 4208.155271056497
refundTicket average exec time = 544.5597206931046
====================================================================

====================================================================
ImplFour class repeat multi thread test finished.
repeat test count: 5
minFullElapsedTimePerEpoch = 317331119, maxFullElapsedTimePerEpoch = 352634489
avgFullElapsedTimePerEpoch = 336040911, midFullElapsedTimePerEpoch = 338270019
minFullElapsedTimeInnerPerEpoch = 316806234, maxFullElapsedTimeInnerPerEpoch = 352129538
avgFullElapsedTimeInnerPerEpoch = 335545626, midFullElapsedTimeInnerPerEpoch = 337802838
fullFuncCallCount = 32000000, avgFuncCallCount = 500000
best_throughPut(func/nano) = 0.020168207959459533
mid_throughput(func/nano) = 0.018919796731971094
avg_throughPut(func/nano) = 0.019045300112283055
best_throughPut_inner(func/nano) = 0.020168207959459533
avg_throughPut_inner(func/nano) = 0.019073412090908914
inquiry average exec time = 2329.708417113861
buyTicket average exec time = 5680.854248587846
refundTicket average exec time = 528.1390226660325
====================================================================

====================================================================
ImplSix class repeat multi thread test finished.
repeat test count: 5
minFullElapsedTimePerEpoch = 382458638, maxFullElapsedTimePerEpoch = 412675470
avgFullElapsedTimePerEpoch = 398349977, midFullElapsedTimePerEpoch = 393838993
minFullElapsedTimeInnerPerEpoch = 381922011, maxFullElapsedTimeInnerPerEpoch = 412155837
avgFullElapsedTimeInnerPerEpoch = 397827505, midFullElapsedTimeInnerPerEpoch = 393380050
fullFuncCallCount = 32000000, avgFuncCallCount = 500000
best_throughPut(func/nano) = 0.01673383567297021
mid_throughput(func/nano) = 0.016250295460205993
avg_throughPut(func/nano) = 0.01606627430532022
best_throughPut_inner(func/nano) = 0.01673383567297021
avg_throughPut_inner(func/nano) = 0.01608737435085088
inquiry average exec time = 3035.369736189798
buyTicket average exec time = 6269.141205642278
refundTicket average exec time = 803.6327783254989
====================================================================

====================================================================
ImplSeven class repeat multi thread test finished.
repeat test count: 5
minFullElapsedTimePerEpoch = 312838935, maxFullElapsedTimePerEpoch = 351552522
avgFullElapsedTimePerEpoch = 340485787, midFullElapsedTimePerEpoch = 347981176
minFullElapsedTimeInnerPerEpoch = 312332169, maxFullElapsedTimeInnerPerEpoch = 351034249
avgFullElapsedTimeInnerPerEpoch = 339983701, midFullElapsedTimeInnerPerEpoch = 347490284
fullFuncCallCount = 32000000, avgFuncCallCount = 500000
best_throughPut(func/nano) = 0.020457811621178164
mid_throughput(func/nano) = 0.018391799446071187
avg_throughPut(func/nano) = 0.018796673001801392
best_throughPut_inner(func/nano) = 0.020457811621178164
avg_throughPut_inner(func/nano) = 0.018824431821806657
inquiry average exec time = 2739.461170760636
buyTicket average exec time = 3861.9832273345337
refundTicket average exec time = 516.4271603287108
====================================================================

====================================================================
ImplEight class repeat multi thread test finished.
repeat test count: 5
minFullElapsedTimePerEpoch = 298422332, maxFullElapsedTimePerEpoch = 351697584
avgFullElapsedTimePerEpoch = 320929263, midFullElapsedTimePerEpoch = 314901798
minFullElapsedTimeInnerPerEpoch = 297956634, maxFullElapsedTimeInnerPerEpoch = 351221896
avgFullElapsedTimeInnerPerEpoch = 320396007, midFullElapsedTimeInnerPerEpoch = 314395657
fullFuncCallCount = 32000000, avgFuncCallCount = 500000
best_throughPut(func/nano) = 0.021446116170689263
mid_throughput(func/nano) = 0.02032379630934975
avg_throughPut(func/nano) = 0.01994208923229291
best_throughPut_inner(func/nano) = 0.021446116170689263
avg_throughPut_inner(func/nano) = 0.019975280153850358
inquiry average exec time = 2820.3039086012905
buyTicket average exec time = 3631.4858439509626
refundTicket average exec time = 561.824894324748
====================================================================

====================================================================
ImplNine class repeat multi thread test finished.
repeat test count: 5
minFullElapsedTimePerEpoch = 1537978994, maxFullElapsedTimePerEpoch = 1636041522
avgFullElapsedTimePerEpoch = 1563765167, midFullElapsedTimePerEpoch = 1547801742
minFullElapsedTimeInnerPerEpoch = 1537405123, maxFullElapsedTimeInnerPerEpoch = 1635477644
avgFullElapsedTimeInnerPerEpoch = 1563205890, midFullElapsedTimeInnerPerEpoch = 1547254500
fullFuncCallCount = 32000000, avgFuncCallCount = 500000
best_throughPut(func/nano) = 0.004161305209608084
mid_throughput(func/nano) = 0.00413489649632401
avg_throughPut(func/nano) = 0.004092686123887808
best_throughPut_inner(func/nano) = 0.004161305209608084
avg_throughPut_inner(func/nano) = 0.004094150387317182
inquiry average exec time = 82.1791611398988
buyTicket average exec time = 3324.1200914786314
refundTicket average exec time = 77219.54505557619
====================================================================

====================================================================
ImplTen class repeat multi thread test finished.
repeat test count: 5
minFullElapsedTimePerEpoch = 412083545, maxFullElapsedTimePerEpoch = 460796575
avgFullElapsedTimePerEpoch = 439762334, midFullElapsedTimePerEpoch = 446943528
minFullElapsedTimeInnerPerEpoch = 411830734, maxFullElapsedTimeInnerPerEpoch = 460472159
avgFullElapsedTimeInnerPerEpoch = 439501355, midFullElapsedTimeInnerPerEpoch = 446693245
fullFuncCallCount = 32000000, avgFuncCallCount = 500000
best_throughPut(func/nano) = 0.015530831254133189
mid_throughput(func/nano) = 0.014319482438058707
avg_throughPut(func/nano) = 0.014553315518832042
best_throughPut_inner(func/nano) = 0.015530831254133189
avg_throughPut_inner(func/nano) = 0.014561957380085894
inquiry average exec time = 2466.636791141968
buyTicket average exec time = 6751.095440801584
refundTicket average exec time = 2729.5588039969102
====================================================================

====================================================================
ImplEleven class repeat multi thread test finished.
repeat test count: 5
minFullElapsedTimePerEpoch = 336452817, maxFullElapsedTimePerEpoch = 363818084
avgFullElapsedTimePerEpoch = 349788693, midFullElapsedTimePerEpoch = 346174430
minFullElapsedTimeInnerPerEpoch = 335872509, maxFullElapsedTimeInnerPerEpoch = 363311937
avgFullElapsedTimeInnerPerEpoch = 349211182, midFullElapsedTimeInnerPerEpoch = 345631079
fullFuncCallCount = 32000000, avgFuncCallCount = 500000
best_throughPut(func/nano) = 0.01902198369764281
mid_throughput(func/nano) = 0.018487789522755912
avg_throughPut(func/nano) = 0.018296760667446732
best_throughPut_inner(func/nano) = 0.01902198369764281
avg_throughPut_inner(func/nano) = 0.01832701909299113
inquiry average exec time = 2309.394075530268
buyTicket average exec time = 6360.014010644911
refundTicket average exec time = 516.4270916142784
====================================================================

====================================================================
ImplTwelve class repeat multi thread test finished.
repeat test count: 5
minFullElapsedTimePerEpoch = 310925141, maxFullElapsedTimePerEpoch = 401792233
avgFullElapsedTimePerEpoch = 346897729, midFullElapsedTimePerEpoch = 350920152
minFullElapsedTimeInnerPerEpoch = 310408523, maxFullElapsedTimeInnerPerEpoch = 401246139
avgFullElapsedTimeInnerPerEpoch = 346375308, midFullElapsedTimeInnerPerEpoch = 350343906
fullFuncCallCount = 32000000, avgFuncCallCount = 500000
best_throughPut(func/nano) = 0.020583732725556598
mid_throughput(func/nano) = 0.018237767091814093
avg_throughPut(func/nano) = 0.018449241563065984
best_throughPut_inner(func/nano) = 0.020583732725556598
avg_throughPut_inner(func/nano) = 0.01847706765518055
inquiry average exec time = 2757.044180561858
buyTicket average exec time = 4108.157709513654
refundTicket average exec time = 479.93949133235793
====================================================================

====================================================================
ImplThirteen class repeat multi thread test finished.
repeat test count: 5
minFullElapsedTimePerEpoch = 341056785, maxFullElapsedTimePerEpoch = 375642689
avgFullElapsedTimePerEpoch = 361656176, midFullElapsedTimePerEpoch = 366357993
minFullElapsedTimeInnerPerEpoch = 340592133, maxFullElapsedTimeInnerPerEpoch = 375155635
avgFullElapsedTimeInnerPerEpoch = 361162392, midFullElapsedTimeInnerPerEpoch = 365837652
fullFuncCallCount = 32000000, avgFuncCallCount = 500000
best_throughPut(func/nano) = 0.018765203571598787
mid_throughput(func/nano) = 0.0174692517217715
avg_throughPut(func/nano) = 0.01769636584334177
best_throughPut_inner(func/nano) = 0.018765203571598787
avg_throughPut_inner(func/nano) = 0.01772056045082346
inquiry average exec time = 3352.1972795879315
buyTicket average exec time = 4177.60234728403
refundTicket average exec time = 896.6680591933809
====================================================================

====================================================================
ImplFourteen class repeat multi thread test finished.
repeat test count: 5
minFullElapsedTimePerEpoch = 388201059, maxFullElapsedTimePerEpoch = 425448366
avgFullElapsedTimePerEpoch = 405726318, midFullElapsedTimePerEpoch = 406216295
minFullElapsedTimeInnerPerEpoch = 387802266, maxFullElapsedTimeInnerPerEpoch = 424901295
avgFullElapsedTimeInnerPerEpoch = 405233770, midFullElapsedTimeInnerPerEpoch = 405724861
fullFuncCallCount = 32000000, avgFuncCallCount = 500000
best_throughPut(func/nano) = 0.016486302269463928
mid_throughput(func/nano) = 0.015755153298318572
avg_throughPut(func/nano) = 0.01577418007179904
best_throughPut_inner(func/nano) = 0.016486302269463928
avg_throughPut_inner(func/nano) = 0.01579335305643456
inquiry average exec time = 3221.7588947522204
buyTicket average exec time = 6250.984167394818
refundTicket average exec time = 920.05397179701
====================================================================

====================================================================
ImplFifteen class repeat multi thread test finished.
repeat test count: 5
minFullElapsedTimePerEpoch = 275344206, maxFullElapsedTimePerEpoch = 307483906
avgFullElapsedTimePerEpoch = 296395704, midFullElapsedTimePerEpoch = 299845976
minFullElapsedTimeInnerPerEpoch = 274823968, maxFullElapsedTimeInnerPerEpoch = 307012169
avgFullElapsedTimeInnerPerEpoch = 295908890, midFullElapsedTimeInnerPerEpoch = 299363456
fullFuncCallCount = 32000000, avgFuncCallCount = 500000
best_throughPut(func/nano) = 0.023243634187820897
mid_throughput(func/nano) = 0.021344291777322368
avg_throughPut(func/nano) = 0.02159275560890046
best_throughPut_inner(func/nano) = 0.023243634187820897
avg_throughPut_inner(func/nano) = 0.021628278893547268
inquiry average exec time = 1847.2147336416774
buyTicket average exec time = 6061.442778982602
refundTicket average exec time = 568.9381493489224
====================================================================

====================================================================
ImplSixteen class repeat multi thread test finished.
repeat test count: 5
minFullElapsedTimePerEpoch = 325376988, maxFullElapsedTimePerEpoch = 424342286
avgFullElapsedTimePerEpoch = 361891902, midFullElapsedTimePerEpoch = 355431044
minFullElapsedTimeInnerPerEpoch = 324938722, maxFullElapsedTimeInnerPerEpoch = 423779921
avgFullElapsedTimeInnerPerEpoch = 361383963, midFullElapsedTimeInnerPerEpoch = 354912487
fullFuncCallCount = 32000000, avgFuncCallCount = 500000
best_throughPut(func/nano) = 0.01966949180806849
mid_throughput(func/nano) = 0.01800630560565216
avg_throughPut(func/nano) = 0.01768483893845185
best_throughPut_inner(func/nano) = 0.01966949180806849
avg_throughPut_inner(func/nano) = 0.017709695656860126
inquiry average exec time = 3173.3482231577664
buyTicket average exec time = 4137.915067969336
refundTicket average exec time = 575.8644588098272
====================================================================

--------------- END TEST THREAD NUM = 64 ---------------
```

### 绘制折线图

分别绘制了针对不同指标下，线程数从4到64的不同实现的变化折线图。

![plot_2](.\plot.png)

### 总结

第一张图纵轴为吞吐量（总操作次数除以总时间（毫秒）），第二张图纵轴为inquiry平均耗时，第三张图纵轴为buyTicket平均耗时，第四张图纵轴为refund平均耗时。

能够总结出以下信息：

1. 针对吞吐量，使用了基于CAS操作的实现，始终是线程数越多，吞吐量越大。只有使用了粗粒度锁的实现1和2，它们在线程数大于32时都出现了吞吐量的下降。
2. 针对吞吐量，实现1和2在线程数较少时还具有优势，但是当线程数大于16时，使用CAS的实现方案要远远优于使用锁的方案。
3. 针对查询，可以看出实现一与实现二在线程数变多时没有发生太大变化，且远远快于实现三四五六七。实现一和二的查询操作复杂度极低，实现三和四、六、七、八的复杂度差不多。只有实现五能够看出明显变慢。这是因为实现五的数据结构的数据规模是其他方案的好多倍，速度要慢得多。
4. 针对购票，可以看出实现1和2在线程数增大时，延时增加的越来越大，它们的延时在线程数增大时是由于粗粒度锁的原因导致的。而基于CAS的方案就增长缓慢。其中实现五仍然由于数据规模的原因，始终速度都很慢。
5. 针对退票，能够看出与购票呈现同样的趋势。但是由于退票时CAS实现中没有搜索的开销，所以他们的差距不大。

最终吞吐量性能上，在64线程时，实现十五达到了最好的性能，约能达到21000的吞吐量。

